---
title: Различия между версиями 3 и 4 пакета SDK для NodeJS — Служба Azure Bot
description: Здесь описаны различия между версиями 3 и 4 пакета SDK для Node.js.
keywords: переход на новую версию SDK Bot Framework, диалоги, состояние
author: mmiele
ms.author: v-mimiel
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.date: 11/28/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 5d614fc34f3daa9deddb2ccedbe58bdef2ba067a
ms.sourcegitcommit: f8b5cc509a6351d3aae89bc146eaabead973de97
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/09/2020
ms.locfileid: "75791046"
---
# <a name="differences-between-the-v3-and-v4-javascript-sdk"></a>Различия между версиями 3 и 4 пакета SDK для JavaScript

Версия 4 пакета SDK Bot Framework поддерживает ту же базовую службу Bot Framework, что и версия 3. Но в версии 4 выполнен рефакторинг кода предыдущей версии пакета SDK для повышения гибкости и улучшения контроля над ботами. Основные изменения в пакете SDK:

- Общие сведения об адаптере бота.
  - Является компонентом стека обработки действий.
  - Выполняет аутентификацию Bot Framework.
  - Управляет входящим и исходящим трафиком между каналом и обработчиком шагов вашего бота, инкапсулируя вызовы в Bot Framework Connector.
  - Инициализирует контекст для каждого шага.
  - Дополнительные сведения см. в статье [Принципы работы бота](../bot-builder-basics.md).
- Выполнен рефакторинг управления состоянием.
  - Данные о состоянии больше не предоставляются в боте автоматически.
  - Управление состоянием теперь осуществляется через соответствующие объекты и методы доступа к свойствам.
  - Дополнительные сведения см. в статье [Управление состоянием](../bot-builder-concept-state.md).
- Новая библиотека диалогов.
  - Диалоги версии 3 необходимо переписать для новой библиотеки диалогов.
  - Диалоги с возможностью оценки Scoreable больше не существуют. Вы можете проверить наличие глобальных команд, прежде чем передавать средства управления в диалоги. В зависимости от архитектуры бота версии 4 это можно сделать в обработчике сообщений или в родительском диалоге. Пример см. в статье [Обработка прерываний со стороны пользователя](../bot-builder-howto-handle-user-interrupt.md).
  - Дополнительные сведения см. в статье [Библиотека диалогов](../bot-builder-concept-dialog.md).

## <a name="activity-processing"></a>Обработка действий

При создании адаптера для бота вы также указываете делегата обработчика сообщений, который будет получать входящие действия от каналов и пользователей. Адаптер создает объект контекста шага для каждого полученного действия. Он передает объект контекста шага обработчику шагов в боте, а затем удаляет объект после завершения шага.

Обработчик шагов может получать действия разных типов. Как правило, диалогам в боте необходимо перенаправлять только действия _сообщений_. Если вы наследуете бота из `ActivityHandler`, обработчик шагов в нем будет пересылать все сообщения о действиях в `OnMessage`. Переопределите этот метод, чтобы добавить логику обработки сообщений. Дополнительные сведения о типах действий см. в статье о [схеме действий](https://github.com/Microsoft/botframework-sdk/blob/master/specs/botframework-activity/botframework-activity.md).

### <a name="handling-turns"></a>Шаги обработки

При обработке сообщений используйте контекст шага, чтобы получить данные о входящем действии и отправить действия пользователю:

|Действие |Description |
|:---|:---|
| Получение входящего действия | Получите свойство `Activity` контекста шага. |
| Создание действия и отправка его пользователю | Вызовите метод `SendActivity` контекста шага.<br/> Дополнительные сведения см. в статьях [Отправка и получение текстовых сообщений](../../rest-api/bot-framework-rest-direct-line-1-1-receive-messages.md) и [Добавление мультимедиа в сообщения](../bot-builder-howto-add-media-attachments.md). |

Класс `MessageFactory` предоставляет некоторые вспомогательные методы для создания и форматирования действий.

### <a name="interruptions"></a>Обработка прерываний

Обрабатывайте такие элементы в цикле сообщений бота. Описание такого процесса для диалогов в версии 4 см. в статье [Обработка прерываний со стороны пользователя](../bot-builder-howto-handle-user-interrupt.md).

## <a name="state-management"></a>Управление данными о состоянии

В версии 3 вы могли хранить данные о беседе в службе "Состояние бота", которая входит в обширный набор служб для Bot Framework. Но после 31 марта 2018 г. эта служба более недоступна. Начиная с версии 4 применяются те же рекомендации по управлению состоянием, что и для любого веб-приложения. Такое управление можно реализовать несколькими способами. Обычно проще всего кэшировать состояние в памяти в том же процессе, но в производственных приложениях состояние следует сохранять в более устойчивом хранилище, например в базе данных SQL или NoSQL или в больших двоичных объектах.

В версии 4 для управления состоянием не используются свойства `UserData`, `ConversationData` и `PrivateConversationData`, а также контейнеры данных.
Управление состоянием теперь осуществляется через соответствующие объекты и методы доступа к свойствам, как описано в статье [Управление состоянием](../bot-builder-concept-state.md).

Версия 4 определяет классы `UserState`, `ConversationState` и `PrivateConversationState`, которые управляют данными состояния для бота. Вам нужно создать метод доступа к свойству состояния для каждого свойства, которое нужно сохранить (а не просто считывать и записывать его в предопределенный контейнер данных).

### <a name="setting-up-state"></a>Настройка состояния

Состояние должно быть настроено в файле точки входа приложения. В приложениях Node.js это обычно файл index.js или app.js. 

1. Инициализируйте один или несколько объектов, реализующих интерфейс `Storage`, предоставляемый botbuilder-core. Вы получите резервное хранилище для данных вашего бота.
    Пакет SDK версии 4 предоставляет несколько [уровней хранения](../bot-builder-concept-state.md#storage-layer).
    Вы также можете реализовать собственные уровни, чтобы подключаться к хранилищам различных типов.
1. Затем при необходимости создайте и зарегистрируйте объекты [управления состоянием](../bot-builder-concept-state.md#state-management).
    Вам доступны те же области, что и в версии 3, и при необходимости вы можете создать другие.
1. Наконец, создайте и зарегистрируйте [методы доступа к свойствам состояния](../bot-builder-concept-state.md#state-property-accessors) для нужных боту свойств.
    В объекте управления состоянием каждый метод доступа к свойству должен иметь уникальное имя.

### <a name="using-state"></a>Использование состояния

Используйте методы доступа к свойствам состояния, чтобы получить и обновить свои свойства, а объекты управления состоянием, чтобы записать какие-либо изменения в хранилище. Так как вам необходимо учитывать особенности параллелизма, ниже описано, как выполнять некоторые стандартные задачи.

| Задача|Description |
|:---|:---|
| Создание метода доступа к свойству состояния | Вызовите метод `createProperty` объекта `BotState`. <br/>`BotState` является абстрактным базовым классом для беседы, закрытой беседы и состояния пользователя. |
| Получение текущего значения свойства | Вызовите процедуру `StatePropertyAccessor.get(TurnContext)`.<br/>Если значение не задано ранее, для его создания будет использоваться фабричный параметр по умолчанию. |
| Сохранение изменений состояний в хранилище | Вызовите `BotState.saveChanges(TurnContext, boolean)` для любого объекта управления состоянием, в котором состояние было изменено до выхода из обработчика шагов. |

### <a name="managing-concurrency"></a>Управление параллелизмом

Возможно, вашему боту потребуется управлять параллелизмом состояния. Дополнительные сведения см. в разделе [Сохранение состояния](../bot-builder-concept-state.md#saving-state) статьи **Управление состоянием** и в разделе [Управление параллелизмом с помощью тегов eTag](../bot-builder-howto-v4-storage.md#manage-concurrency-using-etags) статьи **Запись данных напрямую в хранилище**.

## <a name="dialogs-library"></a>Библиотека диалогов

Ниже приведены некоторые из основных изменений в диалогах:

- Библиотека диалогов теперь имеет вид отдельного пакета npm с именем **botbuilder-dialogs**.
- Управление состоянием диалога осуществляется через метод доступа к свойству и классу состояния `DialogState`.
  - Свойство состояния диалога теперь сохраняется между шагами в отличие от самого объекта диалога.
- В ходе выполнения шага вы создаете контекст диалога для _набора диалогов_.
  - Этот контекст диалога инкапсулирует стек диалога. Эта информация сохраняется в свойстве состояния диалога.
- Обе версии содержат абстрактный класс `Dialog`, но в версии 3 он расширяет класс ActionSet, тогда как в версии 4 он расширяет Object.

### <a name="defining-dialogs"></a>Определение диалогов

Версия 3 предоставляла гибкую возможность реализовать диалоги с помощью класса `Dialog`. Но для этого требовалось создать собственный код для таких функций, как проверка. В версии 4 появились классы запроса, которые автоматически проверяют пользовательский ввод, применяют к нему ограничение по типу (например целое число) и повторно запрашивают данные у пользователя, пока они не будут соответствовать этим ограничениям. В большинстве случаев это позволяет разработчику писать меньше кода.

Теперь вам доступно несколько способов определения диалогов:

|Тип диалога| Description |
|:---|:---|
| Компонентный диалог, наследуемый от класса `ComponentDialog`. | Позволяет инкапсулировать код диалога без конфликтов именования с другими контекстами. См. статью [Повторное использование диалогов](../bot-builder-concept-dialog.md).|
| Каскадный диалог, экземпляр класса `WaterfallDialog`. | Разработан для оптимальной работы с диалогами запроса, которые предлагают пользователю ввести данные и проверяют их. Каскадный диалог автоматизирует большинство процессов, но требует применения определенной формы для кода диалога (см. статью [Реализация процесса общения](../bot-builder-dialog-manage-conversation-flow.md)). |
| Настраиваемый диалог, полученный из абстрактного класса `Dialog`. | Дает максимальную гибкость в аспекте поведения диалогов, но также требует более глубоких знаний о реализации стека диалогов. |

Создавая каскадный диалог, вы определяете шаги диалога в конструкторе. Порядок выполняемых действий строго соответствует тому, в котором вы их объявили, и переход между ними происходит автоматически.

Можно также создать сложные потоки управления с помощью нескольких диалогов, как описано в статье [Создание сложного потока беседы с использованием ветвления и циклов](../bot-builder-dialog-manage-complex-conversation-flow.md).

Чтобы получить доступ к диалогу, вам необходимо разместить его экземпляр в _наборе диалогов_, а затем сгенерировать _контекст диалога_ для такого набора. При создании набора диалогов вам нужно указать метод доступа к свойству состояния диалога. Это позволит платформе сохранять состояние диалога при переходе между шагами. Управление состоянием в версии 4 описано в статье [Управление состоянием](../bot-builder-concept-state.md).

### <a name="using-dialogs"></a>Использование диалогов

Ниже приведен список стандартных операций в версии 3, а также описывается их выполнение в каскадном диалоге. Обратите внимание, что каждый шаг каскадного диалога должен возвращать значение `DialogTurnResult`. В противном случае каскадный диалог может преждевременно завершиться.

| Операция | Версия 3 | версия 4 |
|:---|:---|:---|
| Обработка запуска диалога | Вызовите `session.beginDialog`, передав идентификатор диалога. | Позвони `DialogContext.beginDialog` |
| Отправка действия | Вызовите процедуру `session.send`. | Вызовите процедуру `TurnContext.sendActivity`.<br/>Используйте свойство `Context` контекста шага, чтобы получить контекст шага (`step.context.sendActivity`).  |
| Ожидание ответа пользователя | Вызовите запрос внутри шага каскадного диалога, например `builder.Prompts.text(session, 'Please enter your destination')`. Получите ответ на следующем шаге. | Верните ожидание `TurnContext.prompt`, чтобы начать диалог с запросом. Затем получите результаты на следующем шаге каскадного диалога. |
| Обработка продолжения диалога | Автоматически | Добавьте в каскадный диалог дополнительные шаги или реализуйте `Dialog.continueDialog` |
| Обозначение завершения обработки до следующего сообщения пользователя | Вызовите процедуру `session.endDialog`. | Возвращается значение `Dialog.EndOfTurn`. |
| Запуск дочернего диалога | Вызовите процедуру `session.beginDialog`. | Верните ожидание для метода `beginDialog` контекста шага.<br/>Если дочерний диалог вернет значение, оно будет доступно на следующем шаге каскадного диалога с помощью свойства `Result` контекста шага. |
| Замена текущего диалога новым | Вызовите процедуру `session.replaceDialog`. | Верните ожидание для `ITurnContext.replaceDialog`. |
| Информирование о завершении текущего диалога | Вызовите процедуру `session.endDialog`. | Верните ожидание для метода `endDialog` контекста шага. |
| Выход из диалога | Вызовите процедуру `session.pruneDialogStack`. | Сгенерируйте исключение, которое будет зарегистрировано на другом уровне бота, завершите шаг с состоянием `Cancelled` либо вызовите шаг или `cancelAllDialogs` контекста диалога. |

Другие примечания о коде версии 4:

- Различные производные классы `Prompt` в версии 4 реализуют запросы пользователей в виде отдельных диалогов из двух шагов. См. сведения о том, [как реализовать последовательный поток беседы] [последовательный поток].
- Используйте `DialogSet.createContext`, чтобы создать контекст диалога для текущего шага.
- Используйте свойство `DialogContext.context` из диалога, чтобы получить контекст текущего шага.
- Каскадные шаги имеют параметр `WaterfallStepContext`, который является производным от `DialogContext`.
- Все конкретные классы диалогов и приглашений наследуют от абстрактного класса `Dialog`.
- Идентификатор присваивается при создании компонентного диалога. Каждый диалог в наборе диалогов должен иметь уникальный в пределах этого набора идентификатор.

### <a name="passing-state-between-and-within-dialogs"></a>Передача состояния в диалогах и между ними

В разделах о [состоянии диалога](../bot-builder-concept-dialog.md#dialog-state), [свойствах контекста для каскадного шага](../bot-builder-concept-dialog.md#waterfall-step-context-properties) и [использовании диалогов](../bot-builder-concept-dialog.md#using-dialogs) статьи **Библиотека диалогов** описано, как управлять состоянием диалогов в версии 4.

### <a name="get-user-response"></a>Получение ответа пользователя

Чтобы получить действие пользователя на шаге, получите его из контекста шага.

Чтобы отправить запрос пользователю и получить результат,:

- Добавьте соответствующий экземпляр запроса к вашему набору диалогов.
- Вызовите запрос из шага в каскадном диалоге.
- Извлеките результат из свойства `Result` контекста шага на следующем шаге.

## <a name="additional-resources"></a>Дополнительные ресурсы

Указанные ниже ресурсы содержат дополнительные и справочные сведения.

| Раздел | Description |
| :--- | :--- |
|[Перенос бота на основе пакета SDK для JavaScript версии 3 в версию 4](https://docs.microsoft.com/azure/bot-service/migration/conversion-javascript?view=azure-bot-service-4.0)| Перенос бота для JavaScript из версии 3 в версию 4|
| [Новые возможности Bot Framework](https://docs.microsoft.com/azure/bot-service/what-is-new?view=azure-bot-service-4.0) | Основные возможности и усовершенствования Bot Framework и Azure Bot|
|[Принципы работы бота](../bot-builder-basics.md)|Внутренний механизм бота|
|[Управление состоянием](../bot-builder-concept-state.md)|Абстракции, упрощающие управление состоянием|
|[Библиотека диалогов](../bot-builder-concept-dialog.md)| Основные концепции управления диалогом|
|[Отправка и получение текстовых сообщений](../bot-builder-howto-send-messages.md)|Основной способ взаимодействия бота с пользователями|
|[Отправка мультимедиа](../bot-builder-howto-add-media-attachments.md)|Отправка во вложении мультимедийных материалов, таких как изображения, файлы, видео и аудиозаписи| 
|[Реализация процесса общения](../bot-builder-dialog-manage-conversation-flow.md)| Постановка вопросов как основной способ взаимодействия бота с пользователями|
|[Сохранение данных пользователя и диалога](../bot-builder-howto-v4-state.md)|Отслеживание диалога без отслеживания состояния|
|[Сложный поток беседы](../bot-builder-dialog-manage-complex-conversation-flow.md)|Управление сложным процессом общения |
|[Повторное использование диалогов](../bot-builder-compositcontrol.md)|Создание независимых диалогов для особых сценариев|
|[Обработка прерываний](../bot-builder-howto-handle-user-interrupt.md)| Обработка прерываний для повышения эффективности бота|
|[Схема действий](https://aka.ms/botSpecs-activitySchema)|Схема действий, предпринимаемых в ходе беседы людьми и автоматическим программным обеспечением|
