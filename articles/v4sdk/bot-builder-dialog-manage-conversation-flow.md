---
title: Реализация последовательного потока общения (служба Azure Bot)
description: Сведения о том, как управлять простым процессом общения с помощью диалогов в пакете SDK Bot Framework.
keywords: simple conversation flow, sequential conversation flow, dialogs, prompts, waterfalls, dialog set
author: JonathanFingold
ms.author: kamrani
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.date: 01/28/2020
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: a9ba4f47cfea6cdfcbb947df887397717c012eaa
ms.sourcegitcommit: f3628f48d3471a48773e5d256a75e8fe39717bb6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/05/2020
ms.locfileid: "77035496"
---
# <a name="implement-sequential-conversation-flow"></a>Реализация процесса общения

[!INCLUDE[applies-to](../includes/applies-to.md)]

Сбор данных путем размещения вопросов — это один из основных способов взаимодействия между ботом и пользователями. Библиотека диалогов предоставляет полезные встроенные функции, такие как классы *запросов*, которые позволяют легко задавать вопросы и проверять ответ, чтобы убедиться в том, что он соответствует определенному типу данных или удовлетворяет пользовательские правила проверки.

С помощью библиотеки диалогов можно управлять простыми и сложными процессами общения. В самом простом сценарии взаимодействия бот выполняет фиксированную последовательность действий и завершает диалог. В общем случае диалог нужен для того, чтобы собрать для бота информацию от пользователя. В этом разделе подробно описано, как реализовать простой процесс общения путем создания запросов и их вызова из каскадного диалога.

> [!TIP]
> Примеры написания запросов без использования библиотеки диалогов см. в статье о [создании собственных запросов для сбора вводимых пользовательских данных](bot-builder-primitive-prompts.md).

## <a name="prerequisites"></a>Предварительные требования

- Понимание [основных принципов работы ботов][concept-basics], [управления состоянием][concept-state] и [библиотеки диалогов][concept-dialogs].
- Копия примера **запроса с несколькими шагами** для [**C#** ][cs-sample], [**JavaScript**][js-sample] и [**Python**][python-sample].

## <a name="about-this-sample"></a>Об этом примере

В примере диалога с несколькими запросами мы применим каскадный диалог, несколько запросов и компонентный диалог для реализации простого взаимодействия, в рамках которого пользователю предлагается несколько вопросов. Код диалога циклически перебирает следующие действия:

| Шаги        | Тип запроса  |
|:-------------|:-------------|
| Запрос к пользователю о режиме транспортировки | Запрос выбора |
| Запрос имени пользователя | Запрос текста |
| Запрос к пользователю, готов ли он указать свой возраст | Запрос подтверждения |
| Если получен положительный ответ, запрос возраста пользователя | Запрос числа с проверкой того, что принимается возраст только в диапазоне от 0 до 150 |
| Если пользователь не использует Microsoft Teams, запросите изображение профиля | Запрос вложения с проверкой того, разрешено ли отсутствующее вложение |
| Запрос на подтверждение собранной информации | Повторный запрос подтверждения |

И наконец, если получен положительный ответ, отображается вся собранная информация. В противном случае пользователь получает сообщение о том, что данные не будут сохранены.

## <a name="create-the-main-dialog"></a>Создание главного диалога

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

Чтобы использовать диалоги, установите пакет NuGet **Microsoft.Bot.Builder.Dialogs**.

Бот взаимодействует с пользователем через `UserProfileDialog`. Когда мы создаем класс `DialogBot` в боте, мы назначаем `UserProfileDialog` главным диалогом. Затем бот применяет вспомогательный метод `Run` для доступа к этому диалогу.

![Диалог о профиле пользователя](media/user-profile-dialog.png)

**Dialogs\UserProfileDialog.cs**

Для начала мы создадим `UserProfileDialog` с наследованием от класса `ComponentDialog` и семью шагами.

В конструкторе `UserProfileDialog` создайте каскадные шаги, запросы и каскадный диалог, затем добавьте их в набор диалогов. Запросы должны находиться в том же наборе диалогов, в котором они используются.

[!code-csharp[Constructor snippet](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=21-48)]

Затем мы реализуем действия, которые использует диалог. Чтобы использовать запрос, вызовите его из любого шага диалога и получите результат на следующем шаге с помощью `stepContext.Result`. Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса, пока не будут получены допустимые данные.

Из каскадного шага следует всегда возвращать ненулевое значение `DialogTurnResult`. Без этого диалог может работать неправильно. Здесь мы покажем реализацию `NameStepAsync` в каскадном диалоге.

[!code-csharp[Name step](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=62-67)]

В `AgeStepAsync` мы укажем строку повторного запроса для тех случаев, когда входные данные не пройдут проверку из-за неправильного формата для анализа или несоответствия критерию проверки для конкретного запроса. Если строка повторного запроса не указана, в таких случаях пользователю будет повторно предоставляться исходный текст запроса для получения входных данных.

[!code-csharp[Age step](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=80-99&highlight=10)]

**UserProfile.cs**

Режим транспортировки, имя и возраст пользователя сохраняются в экземпляре класса `UserProfile`.

[!code-csharp[UserProfile class](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/UserProfile.cs?range=11-20)]

**Dialogs\UserProfileDialog.cs**

На последнем шаге мы проверяем значение `stepContext.Result`, возвращенное диалогом, который мы вызвали на предыдущем каскадном шаге. Если возвращаемое значение равно TRUE, мы используем метод доступа для профиля пользователя, чтобы получить и обновить профиль пользователя. Чтобы получить профиль пользователя, мы вызовем метод `GetAsync`, а затем зададим новые значения свойств `userProfile.Transport`, `userProfile.Name`, `userProfile.Age` и `userProfile.Picture`. Наконец, мы сообщим пользователю сводку данных и вызовем метод `EndDialogAsync` для завершения диалога. Завершенный диалог удаляется из стека диалогов, а его результат (если есть) возвращается в родительский диалог. Родительским считается диалог или метод, в котором был запущен только что завершившийся диалог.

[!code-csharp[SummaryStepAsync](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=137-179&highlight=5-11,41-42)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

Чтобы использовать диалоги, в проект следует установить пакет npm **botbuilder-dialogs**.

Бот взаимодействует с пользователем через `UserProfileDialog`. Когда мы создаем `DialogBot` в боте, мы назначаем `UserProfileDialog` главным диалогом. Затем бот применяет вспомогательный метод `run` для доступа к этому диалогу.

![Диалог о профиле пользователя](media/user-profile-dialog-js.png)

**dialogs/userProfileDialog.js**

Для начала мы создадим `UserProfileDialog` с наследованием от класса `ComponentDialog` и семью шагами.

В конструкторе `UserProfileDialog` создайте каскадные шаги, запросы и каскадный диалог, затем добавьте их в набор диалогов. Запросы должны находиться в том же наборе диалогов, в котором они используются.

[!code-javascript[Constructor snippet](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=29-51)]

Затем мы реализуем действия, которые использует диалог. Чтобы использовать запрос, вызовите его из любого шага диалога и получите результат из контекста шага на следующем шаге. Здесь для этого используется `step.result`. Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса, пока не будут получены допустимые данные.

Из каскадного шага следует всегда возвращать ненулевое значение `DialogTurnResult`. Без этого диалог может работать неправильно. Здесь мы покажем реализацию `nameStep` в каскадном диалоге.

[!code-javascript[name step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=79-82)]

В `ageStep` мы укажем строку повторного запроса для тех случаев, когда входные данные не пройдут проверку из-за неправильного формата для анализа или несоответствия критерию проверки, который указан выше в конструкторе, для конкретного запроса. Если строка повторного запроса не указана, в таких случаях пользователю будет повторно предоставляться исходный текст запроса для получения входных данных.

[!code-javascript[age step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=94-105&highlight=5)]

**userProfile.js**

Режим транспортировки, имя и возраст пользователя сохраняются в экземпляре класса `UserProfile`.

[!code-javascript[user profile](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/userProfile.js?range=4-11)]

**dialogs/userProfileDialog.js**

На последнем шаге мы проверяем значение `step.result`, возвращенное диалогом, который мы вызвали на предыдущем каскадном шаге. Если возвращаемое значение равно TRUE, мы используем метод доступа для профиля пользователя, чтобы получить и обновить профиль пользователя. Чтобы получить профиль пользователя, мы вызовем метод `get`, а затем зададим новые значения свойств `userProfile.transport`, `userProfile.name`, `userProfile.age` и `userProfile.picture`. Наконец, мы сообщим пользователю сводку данных и вызовем метод `endDialog` для завершения диалога. Завершенный диалог удаляется из стека диалогов, а его результат (если есть) возвращается в родительский диалог. Родительским считается диалог или метод, в котором был запущен только что завершившийся диалог.

[!code-javascript[summary step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=137-167&highlight=3-9,29-30)]

**Создание метода расширения для запуска каскадного диалога**

Мы определили вспомогательный метод `run` внутри `userProfileDialog`, который будет использоваться для создания контекста диалога и доступа к нему. Здесь `accessor` является методом доступа к свойству состояния для диалога, а `this` — это компонентный диалог для профиля пользователя. Так как компонентные диалоги определяют набор внутренних диалогов, нам следует создать внешний набор диалогов, доступный для кода обработчика сообщений, чтобы использовать его для создания контекста диалога.

Контекст диалога создается путем вызова метода `createContext` и используется для взаимодействия с набором диалогов в обработчике шагов бота. Контекст диалога содержит сведения о текущем шаге, о родительском диалоге, а также состояние диалога для сохранения данных в ходе диалога.

Контекст диалога позволяет начать диалог по идентификатору строки или продолжить текущий диалог (например, выполнить очередной шаг каскадного диалога). Контекст диалога передается через все диалоги и каскадные действия бота.

[!code-javascript[run method](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=59-68)]

# <a name="pythontabpython"></a>[Python](#tab/python)

Чтобы использовать диалоги, установите пакеты PyPI **botbuilder-dialogs** и **botbuilder-ai**, выполнив `pip install botbuilder-dialogs` и `pip install botbuilder-ai` в терминале.

Бот взаимодействует с пользователем через `UserProfileDialog`. Когда мы создаем класс `DialogBot` в боте, мы назначаем `UserProfileDialog` главным диалогом. Затем бот применяет вспомогательный метод `run_dialog` для доступа к этому диалогу.

![Диалог о профиле пользователя](media/user-profile-dialog-python.png)

**dialogs\user_profile_dialog.py**

Для начала мы создадим `UserProfileDialog` с наследованием от класса `ComponentDialog` и семью шагами.

В конструкторе `UserProfileDialog` создайте каскадные шаги, запросы и каскадный диалог, затем добавьте их в набор диалогов. Запросы должны находиться в том же наборе диалогов, в котором они используются.

[!code-python[Constructor snippet](~/../botbuilder-python/samples/python/05.multi-turn-prompt/dialogs/user_profile_dialog.py?range=26-57)]

Затем мы реализуем действия, которые использует диалог. Чтобы использовать запрос, вызовите его из любого шага диалога и получите результат на следующем шаге с помощью `step_context.result`. Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса, пока не будут получены допустимые данные.

Из каскадного шага следует всегда возвращать ненулевое значение `DialogTurnResult`. Без этого диалог может работать неправильно. Здесь мы покажем реализацию `name_step` в каскадном диалоге.

[!code-python[name step](~/../botbuilder-python/samples/python/05.multi-turn-prompt/dialogs/user_profile_dialog.py?range=73-79)]

В `age_step` мы укажем строку повторного запроса для тех случаев, когда входные данные не пройдут проверку из-за неправильного формата для анализа или несоответствия критерию проверки, который указан выше в конструкторе, для конкретного запроса. Если строка повторного запроса не указана, пользователю будет повторно предоставляться исходный текст запроса для получения входных данных.

[!code-python[age step](~/../botbuilder-python/samples/python/05.multi-turn-prompt/dialogs/user_profile_dialog.py?range=100-116)]

**data_models\user_profile.py**

Режим транспортировки, имя и возраст пользователя сохраняются в экземпляре класса `UserProfile`.

[!code-python[user profile](~/../botbuilder-python/samples/python/05.multi-turn-prompt/data_models/user_profile.py?range=7-16)]

**dialogs\user_profile_dialog.py**

На последнем шаге мы проверяем значение `step_context.result`, возвращенное диалогом, который мы вызвали на предыдущем каскадном шаге. Если возвращаемое значение равно TRUE, мы используем метод доступа для профиля пользователя, чтобы получить и обновить профиль пользователя. Чтобы получить профиль пользователя, мы вызовем метод `get`, а затем зададим новые значения свойств `user_profile.transport`, `user_profile.name` и `user_profile.age`. Наконец, мы сообщим пользователю сводку данных и вызовем метод `end_dialog` для завершения диалога. Завершенный диалог удаляется из стека диалогов, а его результат (если есть) возвращается в родительский диалог. Родительским считается диалог или метод, в котором был запущен только что завершившийся диалог.

[!code-python[summary step](~/../botbuilder-python/samples/python/05.multi-turn-prompt/dialogs/user_profile_dialog.py?range=166-204)]

**Создание метода расширения для запуска каскадного диалога**

В файле **helpers\dialog_helper.py** мы определили вспомогательный метод `run_dialog()`, который будет использоваться для создания контекста диалога и доступа к нему. Здесь `accessor` является методом доступа к свойству состояния для диалога, а `dialog` — это компонентный диалог для профиля пользователя. Так как компонентные диалоги определяют набор внутренних диалогов, нам следует создать внешний набор диалогов, доступный для кода обработчика сообщений, чтобы использовать его для создания контекста диалога.

Контекст диалога создается путем вызова метода `create_context` и используется для взаимодействия с набором диалогов в обработчике шагов бота. Контекст диалога содержит сведения о текущем шаге, о родительском диалоге, а также состояние диалога для сохранения данных в ходе диалога.

Контекст диалога позволяет начать диалог по идентификатору строки или продолжить текущий диалог (например, выполнить очередной шаг каскадного диалога). Контекст диалога передается через все диалоги и каскадные действия бота.

[!code-python[run method](~/../botbuilder-python/samples/python/05.multi-turn-prompt/helpers/dialog_helper.py?range=8-19)]

---

## <a name="run-the-dialog"></a>Запуск диалога

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

**Bots\DialogBot.cs**

Обработчик `OnMessageActivityAsync` использует метод `RunAsync`, чтобы начать или продолжить диалог. В `OnTurnAsync` мы используем объекты управления состоянием бота, чтобы передать в хранилище любые изменения состояния. Метод `ActivityHandler.OnTurnAsync` вызывает разные методы обработки действий, например `OnMessageActivityAsync`. Это позволяет сохранить состояние после того, как обработчик сообщений завершит работу, но до завершения самого шага.

[!code-csharp[overrides](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Bots/DialogBot.cs?range=33-48&highlight=5-7)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

Метод `onMessage` позволяет регистрировать прослушиватель, который вызывает метод `run` беседы для запуска или продолжения беседы.

Помимо этого, бот переопределяет метод `ActivityHandler.run` для сохранения состояния беседы и состояния пользователя в хранилище. Это позволяет сохранить состояние после того, как обработчик сообщений завершит работу, но до завершения самого шага.

**bots/dialogBot.js**

[!code-javascript[message listener](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/bots/dialogBot.js?range=24-31&highlight=5)]

[!code-javascript[override](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/bots/dialogBot.js?range=34-43&highlight=7-9)]

# <a name="pythontabpython"></a>[Python](#tab/python)

Обработчик `on_message_activity` использует вспомогательный метод, чтобы начать или продолжить диалог. В `on_turn` мы используем объекты управления состоянием бота, чтобы передать в хранилище любые изменения состояния. Метод `on_message_activity` вызывается последним, после выполнения всех остальных определенных обработчиков, таких как `on_turn`. Это позволяет сохранить состояние после того, как обработчик сообщений завершит работу, но до завершения самого шага.

**bots\dialog_bot.py** [!code-python[overrides](~/../botbuilder-python/samples/python/05.multi-turn-prompt/bots/dialog_bot.py?range=39-51&highlight=4-6)]

---

## <a name="register-services-for-the-bot"></a>Регистрация служб для бота

Этот бот использует следующие _службы_.

- Основные службы бота: поставщик учетных данных, адаптер и реализация бота.
- Службы для управления состоянием: хранилище, состояние пользователя и состояние беседы.
- Диалог, который будет использовать бот.

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

**Startup.cs.**

В `Startup` мы регистрируем службы для бота. Эти службы доступны в других частях кода через механизм внедрения зависимостей.

[!code-csharp[ConfigureServices](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Startup.cs?range=17-39)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

**index.js**

В `index.js` мы регистрируем службы для бота.

[!code-javascript[overrides](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/index.js?range=19-59)]

# <a name="pythontabpython"></a>[Python](#tab/python)

В `app.py` мы регистрируем службы для бота.

[!code-python[configure services](~/../botbuilder-python/samples/python/05.multi-turn-prompt/app.py?range=27-76)]

---

> [!NOTE]
> Хранилище в памяти используется только для тестирования и не предназначено для рабочей среды.
> Для ботов в рабочей среде обязательно используйте постоянное хранилище любого типа.

## <a name="to-test-the-bot"></a>Тестирование бота

1. Установите [Bot Framework Emulator](https://aka.ms/bot-framework-emulator-readme), если вы этого еще не сделали.
1. Выполните этот пример на локальном компьютере.
1. Запустите эмулятор, подключитесь к боту и отправьте несколько сообщений, как показано ниже.

![Тестовый запуск диалога с несколькими запросами](../media/emulator-v4/multi-turn-prompt.png)

## <a name="additional-information"></a>Дополнительные сведения

### <a name="about-dialog-and-bot-state"></a>Сведения о диалоге и состоянии бота

В этом боте мы определили два метода доступа к свойству состояния.

- Один из них создается в состоянии беседы для свойства состояния диалога. Состояние диалога отслеживает позицию пользователя в наборе диалогов. Это свойство обновляется контекстом диалога, например при вызове методов begin dialog или continue dialog.
- Второй создается в состоянии пользователя для свойства профиля пользователя. Бот использует этот метод для отслеживания сведений о пользователе. Мы управляем этим состоянием прямо в коде диалога.

Методы доступа _get_ и _set_ для свойства состояния позволяют получить и сохранить значение этого свойства в кэше объекта управления состоянием. Кэш заполняется автоматически при первом обращении к значению свойства состояния в течение шага, но сохранять его нужно явным образом. Чтобы сохранить изменения в обоих свойствах состояния, мы вызываем метод _save changes_ для соответствующего объекта управления состоянием.

В этом примере обновляется состояние профиля пользователя из диалога. Такой подход допустим для простого бота, но не позволит повторно использовать этот диалог в другом боте.

Есть несколько подходов, позволяющих отделить этапы диалога от состояний бота. Например, после сбора информации вы можете сделать следующее:

- Выполните метод end dialog, чтобы передать собранные данные в виде возвращаемого значения обратно в контекст родительского элемента. Это может быть обработчик шагов бота или предыдущий активный диалог из стека диалогов. Именно так разрабатываются классы запросов.
- Создайте запрос к соответствующей службе. Это может быть хорошим вариантом, если бот выступает в роли интерфейса для более крупной службы.

### <a name="definition-of-a-prompt-validator-method"></a>Определение метода для проверяющего элемента управления запроса

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

**UserProfileDialog.cs**

Ниже приведен пример кода проверяющего элемента управления для определения метода `AgePromptValidatorAsync`. `promptContext.Recognized.Value` содержит анализируемое значение (в нашем примере это целое число из запроса числа). `promptContext.Recognized.Succeeded` указывает, удалось ли в запросе выполнить синтаксический анализ введенных пользователем данных. Проверяющий элемент управления должен возвращать значение false, если значение сочтено недопустимым, и в этом случае диалоговое окно запроса снова отображается пользователю. В противном случае должно вернуться значение true, чтобы принять введенные данные и завершить работу диалогового окна запроса. Обратите внимание, что это значение можно изменить в проверяющем элементе управления в соответствии с вашим сценарием. 

[!code-csharp[prompt validator method](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=181-185)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

**dialogs\userProfileDialog.js**

Ниже приведен пример кода проверяющего элемента управления для определения метода `agePromptValidator`. `promptContext.recognized.value` содержит анализируемое значение (в нашем примере это целое число из запроса числа). `promptContext.recognized.succeeded` указывает, удалось ли в запросе выполнить синтаксический анализ введенных пользователем данных. Проверяющий элемент управления должен возвращать значение false, если значение сочтено недопустимым, и в этом случае диалоговое окно запроса снова отображается пользователю. В противном случае должно вернуться значение true, чтобы принять введенные данные и завершить работу диалогового окна запроса. Обратите внимание, что это значение можно изменить в проверяющем элементе управления в соответствии с вашим сценарием. 

[!code-javascript[prompt validator method](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=169-172)]

# <a name="pythontabpython"></a>[Python](#tab/python)

**dialogs/user_profile_dialog.py**

Ниже приведен пример кода проверяющего элемента управления для определения метода `age_prompt_validator`. `prompt_context.recognized.value` содержит анализируемое значение (в нашем примере это целое число из запроса числа). `prompt_context.recognized.succeeded` указывает, удалось ли в запросе выполнить синтаксический анализ введенных пользователем данных. Проверяющий элемент управления должен возвращать значение false, если значение сочтено недопустимым, и в этом случае диалоговое окно запроса снова отображается пользователю. В противном случае должно вернуться значение true, чтобы принять введенные данные и завершить работу диалогового окна запроса. Обратите внимание, что это значение можно изменить в проверяющем элементе управления в соответствии с вашим сценарием.

[!code-python[prompt validator method](~/../botbuilder-samples/samples/python/05.multi-turn-prompt/dialogs/user_profile_dialog.py?range=207-212)]

---

## <a name="next-steps"></a>Дальнейшие действия

> [!div class="nextstepaction"]
> [Добавление возможности распознавания естественного языка в функционал бота](bot-builder-howto-v4-luis.md)

<!-- Footnote-style links -->

[concept-basics]: bot-builder-basics.md
[concept-state]: bot-builder-concept-state.md
[concept-dialogs]: bot-builder-concept-dialog.md

[prompting]: bot-builder-prompts.md
[component-dialogs]: bot-builder-compositcontrol.md

[cs-sample]: https://aka.ms/cs-multi-prompts-sample
[js-sample]: https://aka.ms/js-multi-prompts-sample
[python-sample]: https://aka.ms/python-multi-prompts-sample
