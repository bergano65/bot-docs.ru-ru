---
title: Управление состоянием | Документация Майкрософт
description: Использование сведений о состоянии с помощью пакета SDK для Bot Framework.
keywords: state, bot state, conversation state, user state
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 05/23/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 037331b10719a47fba42485b19d5ecc9dab08cbe
ms.sourcegitcommit: ea64a56acfabc6a9c1576ebf9f17ac81e7e2a6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/24/2019
ms.locfileid: "66215484"
---
# <a name="managing-state"></a>Управление состоянием

[!INCLUDE [applies-to-v4](../includes/applies-to.md)]

Состояние бота подчиняется тем же принципам, что и современные веб-приложения, и пакет SDK для Bot Framework предоставляет некоторые абстракции, позволяющие упростить управление состоянием.

Как и веб-приложения, бот по своей природе не учитывает состояния. Любой экземпляр бота может обработать любой шаг беседы. Для некоторых ботов такая простота идеальна — либо они могут работать без дополнительных сведений, либо все нужные сведения гарантированно присутствуют во входящем сообщении. Другим ботам сведения о состоянии (например, текущее положение в цепочке беседы или уже полученные данные о пользователе) необходимы, чтобы поддерживать полезную беседу.

**Зачем мне нужно состояние?**

Поддержание состояния позволяет боту повысить информативность бесед путем запоминания некоторых данных о пользователе и (или) диалогах. Например, если вы уже общались ранее с некоторым пользователем, вы можете сохранить информацию о нем и не запрашивать ее повторно. Кроме того, состояние сохраняет данные не только о последнем шаге, что позволяет боту хранить сведения о ходе многоэтапного диалога.

В отношении ботов использование состояния затрагивает несколько уровней, которые мы рассмотрим в этой статье: уровень хранения, управление состоянием (включено в состояние бота на схеме ниже) и методы доступа к свойству состояния. На этой схеме показаны части последовательности взаимодействий этих уровней. Сплошные стрелки обозначают вызов метода, а пунктирными представлены ответы (с возвратом значения или без).

![Состояние бота](media/bot-builder-state.png)

Поток на этой схеме описан в следующих разделах с подробными сведениями по каждому уровню.

## <a name="storage-layer"></a>Уровень хранения

Серверная часть, где фактически хранятся сведения о состоянии, называется *уровнем хранения*. Его можно считать физическим хранилищем, например, в этой роли могут выступать база данных в памяти, платформа Azure или сервер стороннего поставщика услуг.

Пакет SDK для Bot Framework содержит несколько реализация для уровня хранилища.

- **Хранилище в памяти** создает хранилище в памяти для целей тестирования. Хранение данных в памяти следует использовать только для локального тестирования, так как это хранилище является временным и ненадежным. Данные очищаются при каждом перезапуске бота.
- **Хранилище BLOB-объектов** подключается к базе данных хранилища больших двоичных объектов Azure.
- **Хранилище Azure Cosmos DB** подключается к базе данных Cosmos DB NoSQL.

Инструкции по подключению к другим системам хранения можно найти в статье [Запись данных напрямую в хранилище](bot-builder-howto-v4-storage.md).

## <a name="state-management"></a>Управление данными о состоянии

*Управление состоянием* автоматизирует получение и сохранение состояния бота на уровне хранилища. Состояние хранится в виде *свойств состояния*, то есть пар "ключ — значение", которые бот может считывать и записывать через объект управления состоянием, не беспокоясь о конкретной реализации. Свойства состояния определяют, как хранятся эти данные. Например, извлекая свойство со значением определенного класса или объекта, вы заранее знаете структуру этих данных.

Эти свойства состояния размещаются в "контейнерах" с определенной областью видимости, которые представляют собой коллекции для упорядочивания этих свойств. Пакет SDK поддерживает три таких "контейнера":

- состояние пользователя;
- состояние беседы;
- личное состояние беседы.

Все эти контейнеры являются подклассами класса *bot state* (состояние бота), на основе которого вы можете определить и другие типы контейнеров с другими областями действия.

Эти предустановленные контейнеры имеют определенные области видимости.

- Состояние пользователя доступно на любом шаге, который бот выполняет в любой беседе с определенным пользователем на определенном канале.
- Состояние беседы доступно на любом шаге конкретной беседы для любого пользователя (например, в групповой беседе).
- Для личного состояния беседы область ограничивается как конкретным диалогом, так и конкретным пользователем.

> [!TIP]
> Область действий для состояний беседы и пользователя ограничивается определенным каналом.
> Один человек, взаимодействующий с ботом через несколько каналов связи, будет восприниматься как несколько разных пользователей с разными состояниями, по числу используемых каналов.

В каждом из стандартных контейнеров используются ключи, определенные для пользователя, для беседы или для обоих этих объектов. При настройке значения для свойства состояния определяется внутренний ключ с информацией в контексте шага, которая позволяет правильно соотносить пользователей и беседы с контейнерами и свойствами. Определяются следующие ключи:

- Состояние пользователя создает ключ на основе идентификатора канала (*Channel Id*) и идентификатора источника (*From Id*). Например: _{Activity.ChannelId}/users/{Activity.From.Id}#ИмяСвойства_.
- Состояние беседы создает ключ на основе идентификатора канала (*Channel Id*) и идентификатора общения (*Conversation Id*). Например: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}#ИмяСвойства_.
- Личное состояние беседы создает ключ на основе идентификатора канала (*Channel Id*), идентификатора источника (*From Id*) и идентификатора общения (*Conversation Id*). Например: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}/users/{Activity.From.Id}#ИмяСвойства_

### <a name="when-to-use-each-type-of-state"></a>Использование разных типов состояния

С помощью сведений о состоянии беседы можно отслеживать контекст беседы, например:

- задавал ли бот пользователю вопрос, и какой именно;
- на какую тему ведется текущая беседа или о чем была последняя завершенная.

С помощью сведений о состоянии пользователя можно отслеживать сведения о пользователе, например:

- некритические сведения о пользователе, например имя и персональные предпочтения, настройки будильников и (или) оповещений;
- сведения о последней беседе этого пользователя с ботом.
  - Например, бот службы поддержки может отслеживать список продуктов, о которых пользователь задавал вопросы.

Личное состояние беседы хорошо подходит для каналов, где поддерживаются групповые беседы, если в них есть смысл отслеживать определенные сведения о беседе и пользователе одновременно. Например, в боте для школьного класса можно выполнять следующие действия:

- собирать и отображать данные об ответах каждого учащегося на определенный вопрос;
- собирать сведения о результатах каждого учащегося и передавать их ему в частном порядке после каждого сеанса.

Дополнительные сведения о предопределенных контейнерах см. в [практическом руководстве по работе с состоянием](bot-builder-howto-v4-state.md).

### <a name="connecting-to-multiple-databases"></a>Подключение к нескольким базам данных

Если бот должен подключаться к нескольким базам данных, создайте слой хранилища для каждой из них.
Для каждого слоя хранилища создайте объекты управления состоянием, которые потребуются для хранения свойств состояния.

## <a name="state-property-accessors"></a>Методы доступа к свойству состояния

*Методы доступа к свойству состояния* позволяют считывать и сохранять из текущего шага свойства состояния через предоставляемые методы *get*, *set* и *delete*. Чтобы создать метод доступа, укажите имя свойства. Обычно это происходит при инициализации бота. Позже вы сможете использовать этот метод доступа для получения и (или) изменения свойства в состоянии бота.

Методы доступа позволяют пакету SDK получать состояние из базового хранилища и самостоятельно обновляют *кэш состояний* бота. Кэш состояний представляет собой локальный кэш, который бот поддерживает для хранения объекта состояния и обработки чтения и записи без фактического доступа к базовому хранилищу. Если нужного состояния нет в кэше, вызванный метод доступа *get* получает его из хранилища и помещает в кэш. Полученное свойство состояния можно изменять так же, как и обычную локальную переменную.

Метод доступа *delete* удаляет свойство из кэша, а также из базового хранилища.

> [!IMPORTANT]
> При первом вызове метода доступа *get* ему необходимо предоставить фабричный метод, позволяющий создать объект, если он отсутствует в нужном состоянии. Если фабричный метод не предоставлен, создается исключение. Сведения об использовании фабричного метода можно найти в [практическом руководстве по работе с состоянием](bot-builder-howto-v4-state.md).

Чтобы сохранить изменения, внесенные в полученное свойство состояния, обновите свойство в кэше состояния. Для этого можно вызвать метод доступа *set*, который устанавливает значение свойства в кэше, т. е. делает новое значение доступным для чтения и (или) обновления далее на том же шаге. Чтобы сохранить эти данные в базовом хранилище (т. е. сделать их доступными на следующем шаге бота), необходимо [сохранить состояние](#saving-state).

### <a name="how-the-state-property-accessor-methods-work"></a>Как работают методы доступа к свойству состояния

Методы доступа являются основным средством для взаимодействия бота с состоянием. Ниже описаны принцип работы и взаимодействие базовых уровней для каждого из них.

- Метод доступа *get* выполняет следующее:
  - запрашивает данные из кэша состояний;
  - Если нужное свойство находится в кэше, оно сразу возвращается. В противном случае оно извлекается из объекта управления состоянием.
    (Если в состоянии еще нет этого объекта, применяется фабричный метод, предоставленный при вызове метода доступа *get*.)
- Метод доступа *set* выполняет следующее:
  - Сохраняет в кэше состояний новое значение свойства.
- Метод *save changes* в объекте управления состоянием выполняет следующее:
  - Проверяет изменения свойства в кэше состояний.
  - Сохраняет нужное свойство в хранилище.

## <a name="saving-state"></a>Сохранение состояния

Если вы вызываете метод доступа set для сохранения обновленного состояния, свойство состояния не сохраняется в постоянное хранилище, а обновляется только в кэше состояний вашего бота. Чтобы сохранить в постоянное хранилище все внесенные в кэше изменения, следует вызвать метод *save changes* в объекте управления состоянием, который доступен через вышеупомянутую реализацию класса состояния бота (например, состояния пользователя или состояния беседы).

Вызов метода сохранения изменений в объекте управления состоянием (например, для вышеупомянутых контейнеров) сохраняет в выбранный контейнер все свойства, обновленные на текущий момент в кэше состояний, но не затрагивает другие контейнеры в состоянии бота.

> [!TIP]
> Состояние бота реализует подход "приоритет имеет последняя запись", т. е. последняя операция записи отменяет все ранее сохраненные состояния. Это допустимо для многих приложений, но имеет свои побочные эффекты, особенно в сценариях горизонтального масштабирования с определенным уровнем параллелизма и (или) задержек.

Если у вас есть пользовательское ПО промежуточного слоя, которое может обновлять состояние после завершения обработчика шага, есть смысл [управлять состоянием в этом ПО промежуточного слоя](bot-builder-concept-middleware.md#handling-state-in-middleware).

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Состояние в Dialog](bot-builder-concept-dialog.md#dialog-state)
- [Непосредственная запись в хранилище](bot-builder-howto-v4-storage.md)
- [Сохранение данных пользователя и диалога](bot-builder-howto-v4-state.md)
