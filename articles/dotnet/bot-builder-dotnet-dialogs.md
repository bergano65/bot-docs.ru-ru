---
title: Общие сведения о диалогах | Документы Майкрософт
description: Сведения об использовании диалогов в пакете SDK построителя ботов для .NET для моделирования бесед и управления потоком общения.
author: RobStand
ms.author: kamrani
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 12/13/2017
monikerRange: azure-bot-service-3.0
ms.openlocfilehash: 943b206e4991c52f22928d2113977249ff9d9e04
ms.sourcegitcommit: b78fe3d8dd604c4f7233740658a229e85b8535dd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2018
ms.locfileid: "49997581"
---
# <a name="dialogs-in-the-bot-builder-sdk-for-net"></a>Диалоги в пакете SDK построителя ботов для .NET

[!INCLUDE [pre-release-label](../includes/pre-release-label-v3.md)]

> [!div class="op_single_selector"]
> - [.NET](../dotnet/bot-builder-dotnet-dialogs.md)
> - [Node.js](../nodejs/bot-builder-nodejs-dialog-overview.md)

При создании бота с помощью пакета SDK построителя ботов для .NET диалоги можно использовать для моделирования беседы и управления [потоком беседы](../bot-service-design-conversation-flow.md). Каждый диалог — это абстракция, которая инкапсулирует собственное состояние в классе C#, реализующем `IDialog`. Диалог можно сочетать с другими диалогами для наиболее эффективного повторного использования. Кроме того, в контексте диалога сохраняется [стек диалогов](../bot-service-design-conversation-flow.md#dialog-stack), которые активны в беседе в любой момент времени. 

Беседу, содержащую диалоги, можно переносить между компьютерами, что обеспечивает масштабирование реализации бота. При использовании диалогов в пакете SDK построителя ботов для .NET состояние беседы (стек диалогов и состояние каждого диалога в стеке) автоматически сохраняется в выбранном вами хранилище [данных состояния](bot-builder-dotnet-state.md). Это позволяет коду службы бота работать без отслеживания состояния, подобно веб-приложению, которому не требуется хранить состояние сеанса в памяти веб-сервера. 

## <a name="echo-bot-example"></a>Пример бота Echo

Рассмотрим пример бота echo, в котором описывается изменение бота, созданного в [кратком руководстве](bot-builder-dotnet-quickstart.md), для использования диалогов для обмена сообщениями с пользователем.

> [!TIP]
> Для работы с этим примером следуйте указаниям в [кратком](bot-builder-dotnet-quickstart.md) руководстве, чтобы создать бот, а затем внесите в файл **MessagesController.cs** изменения, как описано ниже.

### <a name="messagescontrollercs"></a>MessagesController.cs 

В пакете SDK построителя ботов для .NET библиотека [Builder][builderLibrary] позволяет реализовать диалоги. Чтобы получить доступ к соответствующим классам, импортируйте пространство имен `Dialogs`.

[!code-csharp[Using statement](../includes/code/dotnet-dialogs.cs#usingStatement)]

Добавьте этот класс `EchoDialog` в файл **MessagesController.cs** для представления беседы. 

[!code-csharp[EchoDialog class](../includes/code/dotnet-dialogs.cs#echobot1)]

Затем привяжите класс `EchoDialog` к методу `Post` путем вызова метода `Conversation.SendAsync`.

[!code-csharp[Post method](../includes/code/dotnet-dialogs.cs#echobot2)]

### <a name="implementation-details"></a>Сведения о реализации 

Метод `Post` помечен как асинхронный (`async`), так как построитель ботов использует средства C# для обработки асинхронного взаимодействия. Он возвращает объект `Task`, который представляет задачу, отвечающую за отправку ответов на переданные сообщения. Если возникает исключение, объект `Task`, возвращаемый методом, будет содержать сведения об исключении. 

Метод `Conversation.SendAsync` является ключом к реализации диалогов с помощью пакета SDK построителя ботов для .NET. Он следует <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank">принципу инверсии зависимостей</a> и выполняет следующие действия:

1. создает экземпляры необходимых компонентов;  
2. десериализует состояние беседы (стека диалогов и состояние каждого диалога в стеке) из `IBotDataStore`;
3. возобновляет процесс беседы, если работа бота приостанавливается для ожидания сообщения;
4. отправляет ответы;
5. сериализует измененное состояние общения и сохраняет его обратно в `IBotDataStore`.

При первом запуске беседы диалог не содержит состояние, поэтому `Conversation.SendAsync` создает `EchoDialog` и вызывает его метод `StartAsync`. Метод `StartAsync` вызывает `IDialogContext.Wait` с делегатом продолжения, чтобы указать метод, который должен вызываться при получении нового сообщения (`MessageReceivedAsync`). 

Метод `MessageReceivedAsync` ожидает сообщение, отправляет ответ и ожидает следующее сообщение. При каждом вызове `IDialogContext.Wait` бот переходит в состояние приостановки, и его можно перезапустить на любом компьютере, который получает сообщение. 

Бот, который создается с помощью примеров кода выше, будет отвечать на каждое сообщение, отправляемое пользователем, просто выводя на экран сообщение пользователя с добавлением текста "вы сказали:". Поскольку бот создается с помощью диалогов, его можно развивать для поддержки более сложных бесед без необходимости явно управлять состоянием.

## <a name="echo-bot-with-state-example"></a>Пример бота echo с состоянием

Следующий пример основан на предыдущем, однако мы добавляем возможность отслеживать состояние диалога. Когда класс `EchoDialog` изменяется, как показано в следующем примере кода, бот будет отвечать на каждое отправляемое пользователем сообщение, выводя на экран номер (`count`), за которым следует текст "вы сказали:" и сообщение пользователя. Бот будет продолжать увеличивать значение `count` с каждым ответом, пока пользователь не сбросит счетчик.

### <a name="messagescontrollercs"></a>MessagesController.cs 

[!code-csharp[EchoDialog class](../includes/code/dotnet-dialogs.cs#echobot3)]

### <a name="implementation-details"></a>Сведения о реализации

Как и в первом примере, метод `MessageReceivedAsync` вызывается при получении нового сообщения. Однако на этот раз метод `MessageReceivedAsync` оценивает сообщение пользователя, прежде чем отвечать. Если сообщение пользователя — "reset", встроенный запрос `PromptDialog.Confirm` порождает вложенное диалоговое окно, предлагающее подтвердить сброс счетчика. Вложенное диалоговое окно имеет собственное закрытое состояние, которое не влияет на состояние родительского диалогового окна. Когда пользователь отвечает на запрос, результат вложенного диалогового окна передается в метод `AfterResetAsync`, который отправляет сообщение пользователю, указывая, был ли сброшен счетчик, а затем вызывает `IDialogContext.Wait` с продолжением обратно в `MessageReceivedAsync` для следующего сообщения.

## <a name="dialog-context"></a>Контекст диалога

Интерфейс `IDialogContext`, который передается в каждый метод диалога, предоставляет доступ к службам, необходимым диалоговому окну для сохранения состояния и взаимодействия с каналом. Интерфейс `IDialogContext` состоит из трех интерфейсов: [Internals.IBotData][iBotData], [Internals.IBotToUser][iBotToUser] и [ Internals.IDialogStack][iDialogStack]. 

### <a name="internalsibotdata"></a>Internals.IBotData

Интерфейс `Internals.IBotData` обеспечивает доступ к данным о состоянии беседы (включая состояние частной беседы) для отдельного пользователя и отдельной беседы, сохраняемым соединителем. Данные о состоянии отдельного пользователя удобно использовать для хранения пользовательских данных, не связанных с конкретной беседой, а данные отдельной беседы — для хранения общих данных о беседе. Данные частной беседы удобно использовать для хранения пользовательских данных, связанных с конкретной беседой. 

### <a name="internalsibottouser"></a>Internals.IBotToUser

`Internals.IBotToUser` предоставляет методы для отправки сообщения от бота пользователю. Сообщения могут отправляться вместе с ответом в вызов метода веб-API или напрямую с помощью [клиента соединителя](bot-builder-dotnet-connector.md#create-a-connector-client). Отправка и получение сообщений в контексте диалога гарантирует, что состояние `Internals.IBotData` передается через соединитель.

### <a name="internalsidialogstack"></a>Internals.IDialogStack

`Internals.IDialogStack` предоставляет методы для управления [стеком диалогов](../bot-service-design-conversation-flow.md#dialog-stack). Как правило, управление стеком диалогов будет осуществляться автоматически. Тем не менее могут существовать ситуации, когда требуется явно управлять стеком. Например, может потребоваться вызвать дочерний диалог и добавить его в верхнюю часть стека, пометить текущий диалог как завершенный (тем самым убирая его из стека и возвращая результаты в предыдущий диалог в стеке), приостановить текущий диалог до получения сообщения от пользователя или даже сбросить весь стек диалогов.

## <a name="serialization"></a>Сериализация

Стек диалогов и состояние всех активных диалоговых окон сериализуются в [IBotDataBag][iBotDataBag] для отдельного пользователя и отдельной беседы. Сериализованный BLOB-объект сохраняется в сообщениях, отправляемых ботом в [соединитель](bot-builder-dotnet-concepts.md#connector) и получаемых от него. Для сериализации класс `Dialog` должен содержать атрибут `[Serializable]`. Все реализации `IDialog` в библиотеке [Builder][builderLibrary] помечаются как сериализуемые. 

[Методы Chain](#dialog-chains) предоставляют текучий интерфейс для диалоговых окон, который можно использовать в синтаксисе запросов LINQ. Скомпилированная форма синтаксиса запросов LINQ часто использует анонимные методы. Если эти анонимные методы не ссылаются на среду локальных переменных, такие методы не имеют состояния и сериализуются тривиально. Тем не менее, если анонимный метод записывает любую локальную переменную в среде, соответствующий объект замыкания (созданный компилятором) не помечается как сериализуемый. В этом случае построитель ботов вызывает исключение `ClosureCaptureException`, чтобы определить проблему.

В целях использования отражения для сериализации классов, которые не помечены как сериализуемые, библиотека Builder включает суррогат сериализации на основе отражения, который можно применять для регистрации в [Autofac][autofac].

[!code-csharp[Serialization](../includes/code/dotnet-dialogs.cs#serialization)]

## <a id="dialog-chains"></a> Цепочки диалогов

Хотя вы можете явно управлять стеком активных диалоговых окон с помощью `IDialogStack.Call<R>` и `IDialogStack.Done<R>`, таким стеком можно также управлять неявно с помощью этих текучих методов [Chain][chain].


|           Метод            |  type   |                                 Примечания                                  |
|-----------------------------|---------|------------------------------------------------------------------------|
|     Chain.Select<T, R>      |  LINQ   |           Поддерживает select и let в синтаксисе запросов LINQ.            |
|  Chain.SelectMany<T, C, R>  |  LINQ   |            Поддерживает последовательные from в синтаксисе запросов LINQ.            |
|       Chain.Where<T>        |  LINQ   |                 Поддерживает where в синтаксисе запросов LINQ.                 |
|        Chain.From<T>        | Цепочки  |                Создает новый экземпляр диалога.                |
|       Chain.Return<T>       | Цепочки  |                Возвращает постоянное значение в цепочку.                |
|         Chain.Do<T>         | Цепочки  |               Разрешает побочные эффекты в цепочке.                |
|  Chain.ContinueWith<T, R>   | Цепочки  |                      Создание простой цепочки диалогов.                       |
|       Chain.Unwrap<T>       | Цепочки  |                  Распаковывает диалог, вложенный в другой диалог.                   |
| Chain.DefaultIfException<T> | Цепочки  | Поглощает исключение из предыдущего результата и возвращает default(T). |
|        Chain.Loop<T>        | Ветвь  |                   Выполняет цикл всей цепочки диалогов.                   |
|        Chain.Fold<T>        | Ветвь  |   Свертывает результаты из перечисления диалогов в единый результат.   |
|     Chain.Switch<T, R>      | Ветвь  |            Поддерживает ветвление в разные цепочки диалогов.            |
|     Chain.PostToUser<T>     | Сообщение |                      Публикует сообщение для пользователя.                      |
|     Chain.WaitToBot<T>      | Сообщение |                    Ожидает поступления сообщения в бот.                     |
|    Chain.PostToChain<T>     | Сообщение |              Запускает цепочку с сообщением от пользователя.              |

### <a name="examples"></a>Примеры 

В синтаксисе запросов LINQ используется метод `Chain.Select<T, R>`.

[!code-csharp[Chain.Select](../includes/code/dotnet-dialogs.cs#chain1)]

Или метод `Chain.SelectMany<T, C, R>`.

[!code-csharp[Chain.SelectMany](../includes/code/dotnet-dialogs.cs#chain2)]

Методы `Chain.PostToUser<T>` и `Chain.WaitToBot<T>` публикуют сообщения от бота для пользователя и наоборот.

[!code-csharp[Chain.PostToUser](../includes/code/dotnet-dialogs.cs#chain3)]

Метод `Chain.Switch<T, R>` выполняет ветвление потока диалогов беседы.

[!code-csharp[Chain.Switch](../includes/code/dotnet-dialogs.cs#chain4)]

Если `Chain.Switch<T, R>` возвращает вложенный `IDialog<IDialog<T>>`, тогда внутренний метод `IDialog<T>` можно распаковать с помощью `Chain.Unwrap<T>`. Это позволяет выполнять ветвление бесед по разным путям связанных диалогов (возможно, разной длины). В этом примере показан более сложный пример ветвления диалогов, написанный в стиле текучей цепочки с неявным управлением стеком.

[!code-csharp[Chain.Switch](../includes/code/dotnet-dialogs.cs#chain5)]

## <a name="next-steps"></a>Дополнительная информация

Диалоговые окна управляют потоком беседы между ботом и пользователем. Диалоговое окно определяет способ взаимодействия с пользователем. Бот может использовать несколько диалогов, организованных в стеки, для ведения беседы с пользователем. В следующем разделе показано, как стек диалогов увеличивается и уменьшается по мере создания и удаления диалогов в стеке.

> [!div class="nextstepaction"]
> [Управление потоком беседы с помощью диалогов](bot-builder-dotnet-manage-conversation-flow.md)


[builderLibrary]: /dotnet/api/microsoft.bot.builder.dialogs

[iBotData]: /dotnet/api/microsoft.bot.builder.dialogs.internals.ibotdata

[iBotToUser]: /dotnet/api/microsoft.bot.builder.dialogs.internals.ibottouser

[iDialogStack]: /dotnet/api/microsoft.bot.builder.dialogs.internals.idialogstack

[iBotDataBag]: /dotnet/api/microsoft.bot.builder.dialogs.ibotdatabag

[autofac]: /dotnet/api/microsoft.bot.builder.autofac.base

[chain]: /dotnet/api/microsoft.bot.builder.dialogs.chain
