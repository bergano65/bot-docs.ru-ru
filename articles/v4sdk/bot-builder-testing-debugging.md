---
title: Рекомендации по тестированию и отладке бота | Документация Майкрософт
description: Сведения о тестировании и отладке бота.
keywords: testing principles, mock elements, faq, testing levels
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.date: 04/09/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 27516a73f625eea9c6d2cf8a09234f4068d380e3
ms.sourcegitcommit: b78fe3d8dd604c4f7233740658a229e85b8535dd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2018
ms.locfileid: "49997461"
---
# <a name="testing-and-debugging-guidelines"></a>Рекомендации по тестированию и отладке бота

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

Боты — это сложные приложения, где работают вместе много различных частей. Как и в любом другом сложном приложении, это может привести к некоторым нестандартным ошибкам или бот может вести себя иначе, чем ожидалось.

Тестирование, а затем отладка бота иногда может быть трудной задачей. У каждого разработчика есть собственный предпочтительный способ выполнения этой задачи. Приведенные ниже рекомендации — это предложения для использования, которые применяются к подавляющему большинству ботов.

## <a name="testing-your-bot"></a>Тестирование бота

Приведенные ниже рекомендации представлены на трех различных **уровнях**.  На каждом уровне тестирование усложняется и добавляются новые функции, поэтому мы рекомендуем сначала освоить один уровень, прежде чем переходить к следующему. Это позволит вам выявить и исправить проблемы самого низкого уровня, прежде чем уровни усложнятся.

В лучшей методике тестирования будут рассмотрены различные способы ее применения. Это может быть безопасность, интеграция, неправильно сформированные URL-адреса, эксплойты проверки, коды состояния HTTP, полезные данные JSON, значения NULL и т. д. Если ваш бот обрабатывает все сведения, затрагивающие конфиденциальность пользователей, это особенно важно.

### <a name="level-1-use-mock-elements"></a>Уровень 1. Использование макетов элементов

На первом уровне тестирования необходимо убедиться, что каждый компонент вашего приложения, или в данном случае бота, работает должным образом. Чтобы этого добиться, можно воспользоваться макетами элементов для того, что вы сейчас не тестируете. В справочных целях этот уровень можно рассматривать как модульное и интеграционное тестирование.

**Использование макетов элементов для тестирования отдельных разделов**

Макетирование максимального количества элементов обеспечивает лучшую изоляцию тестируемого объекта. Макетами элементов может быть хранилище, адаптер, ПО промежуточного слоя, конвейер действия, каналы и все, что напрямую не является частью бота. Это может также быть временное удаление определенных аспектов, таких как ПО промежуточного слоя, являющегося частью тестируемого бота, для изоляции каждого компонента. Тем не менее, если вы тестируете ПО промежуточного слоя, возможно, вы захотите макетировать бот вместо этого.

Макетирование элементов может принимать разнообразные формы — от замены элемента другим известным объектом до реализации простой функции Hello World. Это может также принимать форму простого удаления элемента, если он не нужен, или его можно принудительно настроить, чтобы он не выполнял никаких действий. 

На этом уровне следует испробовать отдельные методы и функции в пределах бота. Тестирование отдельных методов можно выполнить через встроенные модульные тесты, которые рекомендуются, с помощью собственного тестового приложения или набора тестов либо вручную в вашей среде IDE. 

**Использование макетов элементов для тестирования более крупных функций**

Когда вы будете довольны поведением каждого метода, используйте эти макеты элементов для тестирования более полных возможностей в боте. Это показывает, как несколько уровней могут работать вместе для взаимодействия с пользователем. 

Для этого предоставлен набор средств. Например, [Azure Bot Framework Emulator](https://github.com/Microsoft/BotFramework-Emulator) предоставляет эмулированный канал для обмена данными с ботом. Использование эмулятора гораздо сложнее, чем просто модульное и интеграционное тестирование, и поэтому оно охватывает следующий уровень тестирования.

### <a name="level-2-use-a-direct-line-client"></a>Уровень 2. Использование клиента Direct Line

Убедившись, что ваш бот работает надлежащим образом, выполните следующий шаг — подключите его к каналу. Чтобы сделать это, разверните бот на промежуточном сервере и создайте собственный клиент Direct Line, к которому будет подключен бот.
<!--IBTODO [Direct Line client](bot-builder-howto-direct-line.md)-->

Создание собственного клиента позволяет определить внутреннюю работу канала, а также специально тестировать ответ бота на обмен определенными действиями. После подключения к клиенту выполните тесты, чтобы настроить состояние вашего бота и проверить возможности. Если бот использует такую возможность, как распознавание речи, ее можно проверить с помощью этих каналов.

Используя и Emulator, и Веб-чат на портале Azure, можно узнать больше о взаимодействии бота с различными каналами.

### <a name="level-3-channel-tests"></a>Уровень 3. Проверка канала

Когда вы будете уверены в независимой производительности своего бота, важно ознакомиться с принципами работы с различными каналами, на которых бот будет доступен. 

Способы достижения этого могут сильно различаться — от использования различных каналов и браузеров до использования стороннего средства, такого как [Selenium](https://docs.seleniumhq.org/), для взаимодействия через канал и получения ответов от бота.

### <a name="other-testing"></a>Другие виды тестирования

Различные виды тестирования можно выполнять в сочетании с указанными уровнями или различными способами, такими как нагрузочное тестирование, тестирование производительности или профилирование действий вашего бота. Visual Studio предоставляет методы, с помощью которых можно сделать это локально, а также [набор средств](https://azure.microsoft.com/en-us/solutions/dev-test/) для тестирования приложения, а [портал Azure](https://portal.azure.com) предоставляет сведения о производительности бота.

## <a name="debugging"></a>Отладка

Отладка бота выполняется как и у других многопоточных приложениях с возможностью настраивать точки останова или использовать такие возможности, как окно интерпретации. 

Боты следуют парадигме программирования, управляемой событиями. Получить правильное представление о ней может быть тяжело, если вы с ней не знакомы. Если состояние вашего бота не отслеживается, он многопоточный и работает с асинхронными вызовами и вызовами ожидания, это может вызвать непредвиденные ошибки. Так как отладка бота работает подобно другим многопоточным приложениям, мы обсудим некоторые вспомогательные предложения, средства и ресурсы.

**Основные сведения о действиях бота с эмулятором**

Бот имеет дело с различными типами [действий](bot-builder-basics.md#the-activity-processing-stack) помимо обычных действий с _сообщениями_. С помощью [эмулятора](../bot-service-debug-emulator.md) мы покажем, что это за действия, когда они выполняются и какие сведения они содержат. Понимание этих действий поможет вам создавать коды бота эффективно и позволит проверить, соответствуют ли вашим ожиданиям действия, которые отправляет и получает бот.

**Сохранение и извлечение данных о взаимодействии пользователя с расшифровками**

Хранилище BLOB-объектов расшифровки предоставляет специальный ресурс, который позволяет [хранить и извлекать расшифровки](bot-builder-howto-v4-storage.md), содержащие сведения о взаимодействии пользователей с ботом.  

Кроме того, после сохранения вводимых пользователем данных при взаимодействии, с помощью _обозревателя хранилища_ Azure можно вручную просмотреть данные, содержащиеся в расшифровках, которые хранятся в соответствующем хранилище BLOB-объектов. В следующем примере показан открытый _обозреватель хранилищ_ из настроек для _mynewtestblobstorage_. Чтобы открыть окно с сохраненными данными, которые ввел пользователь, выберите контейнер больших двоичных объектов > ChannelId > TranscriptId > ConversationId.

![Просмотр_сохраненного_текста_расшифровки](./media/examine_transcript_text_in_azure.png)

Откроется окно с сохраненными данными в формате JSON, которые ввел пользователь. Введенные пользователем данные сохраняются с ключом _text:_.

**Принципы работы ПО промежуточного слоя**

[ПО промежуточного слоя](bot-builder-concept-middleware.md) может не быть интуитивно понятным при первой попытке использования, особенно в отношении продолжения или сокращения выполнения. ПО промежуточного слоя может выполняться в начале или в конце очереди с помощью вызова к делегату `next()`, который указывает, когда выполнение необходимо передать в логику бота. 

Если вы используете несколько компонентов ПО промежуточного слоя, делегат может передать выполнение в различные компоненты ПО промежуточного слоя, если ваш конвейер так ориентирован. Сведения о [конвейере ПО промежуточного слоя бота](bot-builder-concept-middleware.md#the-bot-middleware-pipeline) помогают разъяснить эту идею.

Если делегат `next()` не вызывается, это называется [маршрутизацией короткого замыкания](bot-builder-concept-middleware.md#short-circuiting). Это происходит, когда ПО промежуточного слоя выполняет текущее действие и определяет, что нет необходимости передавать выполнение. 

Знание о времени и причине сокращений ПО промежуточного слоя помогает определить, какие части ПО промежуточного слоя должны быть первыми в конвейере. Кроме того, знание о том, что произойдет, особенно важно при использовании встроенного ПО промежуточного слоя, предоставляемого пакетом SDK или другими разработчиками. Некоторые считают, что лучше сначала создать собственное ПО промежуточного слоя, чтобы немного поэкспериментировать, и лишь затем углубляться во встроенное ПО промежуточного слоя.

Например, решение [QnA maker](bot-builder-howto-qna.md) призвано обрабатывать определенные взаимодействия и сокращать конвейер, что может вызывать путаницу при первом изучении способов его использования.

**Сведения о состоянии**

Отслеживание состояния является важной частью бота, особенно для сложных задач. В целом рекомендуется обрабатывать действия как можно быстрее, а также позволить обработке завершиться, чтобы состояние сохранялось. Действия могут отправляться в бот практически в одно и то же время, и это может привести к ошибкам из-за асинхронной архитектуры.

Самое главное — убедитесь, что состояние сохраняется тем способом, который соответствует вашим ожиданиям. В зависимости от того, где находится ваше сохраненное состояние, с помощью эмуляторов хранилища для [Cosmos DB](https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator) и [Хранилища таблиц Azure](https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator) можно проверить это состояние, прежде чем использовать рабочее хранилище.

**Использование обработчиков действий**

Обработчики действий представляют еще один уровень сложности, особенно если каждое действие выполняется в независимом потоке (или рабочей роли в зависимости от языка). В зависимости от того, что делают обработчики, это может вызвать проблемы, где текущее состояние не соответствует вашим ожиданиям.

Встроенные состояния записываются в конце очереди, тем не менее все действия, создаваемые очередью, выполняются независимо от конвейера очереди. Часто это не имеет значения, но если обработчик действия изменяет состояние, необходимо перезаписать состояние, чтобы оно содержало изменение. В этом случае конвейер очереди может ожидать, пока действие завершит обработку до завершения, чтобы убедиться, что оно записывает правильные данные о состоянии для этой очереди.

Метод _действия отправки_ и его обработчики представляют собой уникальную проблему, если необходимо вывести данные пользователю, так как просто вызов _действия отправки_ из этого метода приводит к бесконечному разветвлению потоков. Вы можете обойти эту проблему, добавив сообщение отладки в исходящие данные или записав в другое расположение, такое как консоль или файл, чтобы избежать сбоя бота.


## <a name="additional-resources"></a>Дополнительные ресурсы
* [Отладка в Visual Studio](https://docs.microsoft.com/en-us/visualstudio/debugger/index)
* [Отладка, трассировка и профилирование](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/) для Bot Framework
* Для методов, которые не нужно добавлять в рабочий код, используйте [ConditionalAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=netcore-2.0) 
* Для просмотра сетевого трафика используйте такие инструменты, как [Fiddler](https://www.telerik.com/fiddler) 
* [Репозиторий средств бота](https://github.com/Microsoft/botbuilder-tools)
* Платформы могут помочь с тестированием, например [Moq](https://github.com/moq/moq4)
