---
title: Реализация пользовательского хранилища для бота | Документация Майкрософт
description: Как создать пользовательское хранилище с помощью пакета SDK Bot Framework версии 4.0
keywords: custom, storage, state, dialog
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 05/23/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 138f3c943fc6c4a7882e808c3f280d4ebe04f62f
ms.sourcegitcommit: 409e8f89a1e9bcd0e69a29a313add424f66a81e1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/17/2019
ms.locfileid: "67153075"
---
# <a name="implement-custom-storage-for-your-bot"></a>Реализация пользовательского хранилища для бота

[!INCLUDE[applies-to](../includes/applies-to.md)]

Взаимодействия бота делятся на три категории: во-первых, обмен действиями со службой Azure Bot, во-вторых, загрузка и сохранение состояний диалога в хранилище, и, наконец, взаимодействие со всеми остальными внутренними службами, которые потребуются для выполнения задач бота.

![Диаграмма горизонтального масштабирования](../media/scale-out/scale-out-interaction.png)


## <a name="prerequisites"></a>Предварительные требования
- Полный пример кода, используемый в этой статье можно найти здесь: [Пример C#](http://aka.ms/scale-out).

В этой статье мы изучим семантику взаимодействий бота со службой Azure Bot и хранилищем.

Bot Framework включает реализацию по умолчанию, которая хорошо подойдет для большинства приложений. Вам достаточно будет объединить все компоненты в нескольких строках кода инициализации. Многие из этих примеров демонстрируют именно такой вариант.

Эти примеры в основном приводятся для того, чтобы описать варианты действий на случай, если стандартная семантика реализации в вашем приложении будет работать не совсем так, как ожидается. Главное, что важно понять — это платформа, а не готовое приложение с предопределенным поведением. Другими словами, многие механизмы на этой платформе служат просто примерами реализации по умолчанию, но ни в коем случае не единственным возможным вариантом.

В частности, платформа не навязывает конкретных взаимосвязей между обменом действиями со службой Azure Bot и сведениями о состоянии бота, которые она загружает и (или) сохраняет. В ней просто реализован вариант по умолчанию. Мы дополнительно подкрепим это напоминание, создав альтернативную реализацию этого механизма с другой семантикой. Альтернативное решение ничем не хуже для самой платформы, а для разрабатываемого приложения может оказаться даже лучше. Здесь все зависит от конкретного сценария.

## <a name="behavior-of-the-default-botframeworkadapter-and-storage-providers"></a>Поведение для адаптера BotFrameworkAdapter по умолчанию и поставщиков хранилища

Сначала рассмотрим реализацию по умолчанию, которая предоставляется в пакетах платформы, как показано на следующей схеме:

![Диаграмма горизонтального масштабирования](../media/scale-out/scale-out-default.png)

Получив определенное действие, бот загружает состояние соответствующей беседы. Затем он выполняет логику диалога, определенную для текущего состояния и (или) полученного действия. В процессе выполнения диалога создаются одно или несколько действий, которые немедленно отправляются пользователю. Завершив обработку диалога, бот сохраняет новое состояние взамен предыдущего.

Здесь важно учесть несколько моментов, которые могут привести к ошибкам.

Во-первых, если операция сохранения по любой причине завершится ошибкой, неявно нарушится синхронизация бота. Пользователь увидит в канале сообщение и будет уверен, что состояние беседы изменилось, тогда как фактически оно останется прежним. Такая ситуация обычно хуже, чем успешное сохранение текущего состояния и ответного сообщения. Такую ситуацию можно учесть в структуре диалога, например создать дополнительные запросы для подтверждения, которые будут выглядеть избыточными в других ситуациях. 

Во-вторых, если реализация развертывается на нескольких узлах, состояние может быть случайно перезаписано. При этом диалог даже успешно отправит в канал подтверждающие сообщения, что внесет еще больше путаницы. Например, если при работе бота приема заказов на пиццу, развернутого в нескольких экземплярах, пользователь в ответ на вопрос о начинке укажет грибы и сразу же укажет сыр, эти последовательные действия могут быть отправлены в разные экземпляры бота. В таком случае возникает состояние гонки, при котором один из компьютеров перезапишет сохраненное другим компьютером состояние. В нашем примере это приведет к тому, что пользователь получит уже отправленные ответы с подтверждением обеих начинок: грибов и сыра. Но в пицце, которую ему доставят, будет только одна из этих начинок: грибы или сыр.

## <a name="optimistic-locking"></a>Оптимистическая блокировка

Решение заключается в том, чтобы создать блокировку для работы с состояниями. Здесь мы применим стиль, который называется оптимистической блокировкой. Это означает, что каждый компонент системы будет работать так, как если бы других экземпляров не существовало, а мы будем дополнительно отслеживать нарушения параллелизма уже после обработки. На первый взгляд это выглядит сложным, но реализация на основе облачных технологий хранения и правильных расширений для платформы ботов будет очень простой.

Мы применим стандартный механизм HTTP на основе заголовка тега сущности (ETag). Чтобы понять приведенный ниже код, важно сначала как следует разобраться в основном механизме. На схеме ниже показана вся последовательность действий.

![Диаграмма горизонтального масштабирования](../media/scale-out/scale-out-precondition-failed.png)

На схеме представлен пример с двумя клиентами, которые выполняют обновление одного ресурса. Когда клиент отправляет запрос GET, полученный в ответе от сервера ресурс дополняется заголовком ETag. Заголовок ETag содержит непрозрачное значение, которое обозначает состояние ресурса. ETag обновляется при любом изменении ресурса. Когда клиент завершит обновление сведений о состоянии, он отправляет ресурс обратно на сервер в запросе POST, присоединяя к нему ранее полученное значение ETag в заголовке предварительного условия If-Match. Если значение ETag не соответствует последнему отправленному сервером значению (учитываются любые ответы любому клиенту), проверка предварительного условия завершается сбоем с кодом состояния "412: ошибка в предусловии". Такое сообщение информирует клиента, от которого поступил запрос POST, что состояние ресурса уже изменилось. Обычно в ответ на эту ошибку клиент повторно получает ресурс с помощью запроса GET, повторно применяет нужные изменения и повторно отправляет ресурс на сервер в запросе POST. Скорее всего, второй запрос POST будет выполнен успешно, если за время выполнения этой процедуры другие клиенты не изменяли этот же ресурс снова. Но даже если это так, клиент просто повторит попытку еще раз.

Такой процесс называется "оптимистическим", так как клиент при получении ресурса для обработки не "блокирует" этот ресурс в прямом смысле, то есть не ограничивает обращения к нему от других клиентов. Любые конфликты между клиентами в отношении состояния ресурса никак не выявляются до завершения обработки. Для распределенных систем такая стратегия обычно дает более оптимальный результат, чем "пессимистическая блокировка".

Оптимистический механизм блокировки, который мы рассмотрели выше, основан на безопасности повторного выполнения логики обработки. Как можно легко догадаться, эта безопасность зависит от характера вызовов к внешним службам. Для этой схемы лучше всего, если внешние службы являются идемпотентными. В компьютерной теории идемпотентной называется такая операция, которая не приводит ни к каким дополнительным последствиям при повторном выполнении с теми же входными параметрами. Этому определению соответствуют "чистые" службы HTTP REST, которые поддерживают запросы GET, PUT и (или) DELETE. Логика этих зависимостей интуитивно понятна: наш бот может повторять попытки обработки и для него очень удобно, что повторение вызовов внешних служб не имеет никаких побочных эффектов. В рамках дальнейшего обсуждения мы предполагаем, что оказались в идеальном мире и все серверные службы из правой части рисунка (в начале этой статьи) являются идемпотентными службами HTTP REST. Это позволит нам забыть про них и сосредоточиться на обмене действиями.

## <a name="buffering-outbound-activities"></a>Буферизация исходящих действий

Отправка действия не является идемпотентной операцией, и мы даже не можем описать идемпотентную логику для этого сценария. Ведь эти действия часто содержат передаваемые сообщения, которые добавляются в представление и (или) проговариваются агентом преобразования текста в речь.

При отправке сообщений для нас важно избежать повторной и многократной отправки. Проблема здесь заключается в том, что механизм оптимистической блокировки требует возможности многократно запускать логику обработки. Но у нас есть простое решение: помещать все исходящие действия диалога в буфер, пока не станет ясно, что повторять выполнение логики больше не потребуется. Например, пока операция сохранения не будет успешно выполнена. Нам нужна примерно такая последовательность операций:

![Диаграмма горизонтального масштабирования](../media/scale-out/scale-out-buffer.png)

Если нам удастся создать цикл повторных попыток для выполнения диалога, то при наличии обстоятельств, приводящих к сбою операции сохранения, мы получим следующее поведение:

![Диаграмма горизонтального масштабирования](../media/scale-out/scale-out-save.png)

Добавление этого механизм к схеме из предыдущего примера позволит полностью избавиться от ошибочных подтверждений при добавлении в заказ начинок для пиццы. Таким образом, несмотря на масштабирование развертывания на несколько компьютеров, мы фактически сериализовали все обновления состояния с помощью механизма оптимистической блокировки. Теперь в нашем боте для заказа пиццы можно даже включить сообщение о правильном состоянии в подтверждение добавления элемента. Например, если пользователь быстро вводит слова "cheese" (сыр) и "mushroom" (грибы), не дожидаясь промежуточного ответа бота, мы сможем сформировать ответы "pizza with cheese" (пицца с сыром) и далее "pizza with cheese and mushroom" (пицца с сыром и грибами).

На схеме последовательности можно заметить, что ответы могут теряться после успешной операции сохранения, но они точно так же могут теряться на любом этапе коммуникации. С этой проблемой инфраструктура управления состояниями ничего сделать не может. Для ее решения нам потребуется протокол более высокого уровня и, возможно, даже с участием пользователя канала. Например, если со стороны пользователя будет казаться, что бот ничего не ответил, пользователь может повторить последнее действие или сделать что-то еще в этом роде. Здесь важно, что мы вправе ожидать некоторое количество временных сбоев в сценарии из-за таких проблем, но не вправе требовать, чтобы пользователь был готов к ошибочным положительным подтверждениям и (или) другим непреднамеренным сообщениям. 

Собрав все эти фрагменты в единую схему в пользовательском решении для хранения, мы получим три дополнительные функции, которые отсутствуют в стандартной реализации. Во-первых, мы применим ETag для обнаружения конфликтов, во-вторых, будем повторять логику обработки при обнаружении несоответствий в ETag и, в-третьих, поместим в буфер все исходящие действия до успешного сохранения состояния. В оставшейся части этой статьи мы опишем реализацию этих трех функциональных компонентов.

## <a name="implementing-etag-support"></a>Реализация поддержки ETag

Для поддержки модульного тестирования мы начнем с определения интерфейса с поддержкой ETag для нового хранилища. Наличие интерфейса позволит нам создать две версии: одна будет выполняться в памяти для модульных тестов, чтобы не загружать сеть, а вторая будет предназначена для рабочей среды. Кроме того, интерфейс значительно упростит применение механизмов введения зависимостей, который реализован в ASP.NET.

Интерфейс содержит методы Load и Save. Оба они принимают в качестве параметра ключ, который определяет текущее состояние. Метод Load будет возвращать данные и связанный с ними ETag. Метод Save будет принимать те же данные. Выходные данные метода Save будут содержать логическое значение. Оно подтверждает, что значения ETag совпали и сохранение выполнено успешно. Это значение следует рассматривать не как индикатор ошибок общего характера, а только как индикатор несоблюдения конкретного предварительного условия. Поэтому мы реализуем его как код возврата, а не как исключение, и создадим вокруг него логику потока управления в форме цикла повторных попыток.

Так как самый нижний уровень хранилища должен быть подключаемым, мы намеренно отказались от любых требований к сериализации, но хотим указать для содержимого обязательный формат JSON, чтобы в реализации хранилища можно было задать значение content-type. В .NET это проще и логичнее всего реализовать через типы аргументов, в частности этому аргументу содержимого мы присвоим тип JObject. В JavaScript и TypeScript для этого используется регулярный собственный объект.  

В результате мы получаем следующий интерфейс:

**IStore.cs**  
[!code-csharp[IStore](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/IStore.cs?range=14-19)]

Его реализация в хранилище BLOB-объектов Azure не составляет никаких трудностей.

**BlobStore.cs**  
[!code-csharp[BlobStore](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/BlobStore.cs?range=18-101)]

Как вы видите, основную работу выполняет хранилище BLOB-объектов. Обратите внимание, как перехватываются конкретные исключения и как они приводятся в соответствие с ожиданиями вызывающего кода. Мы хотим, чтобы исключение "Не найдено" при загрузке возвращало значение null, а исключение "Необходимое условие не выполнено" при сохранении возвращало логическое значение.

Весь исходный код доступен в соответствующем [примере](https://aka.ms/scale-out), который включает также реализацию хранилища в памяти.

## <a name="implementing-the-retry-loop"></a>Реализация цикла повторных попыток
Основной вид этого цикла напрямую определяется поведением, которое представлено на схеме последовательности.

Получив действие, мы создаем ключ для состояния соответствующей беседы. Зависимость между действием и беседой никак не изменяется. Поэтому мы сохраним логику создания ключа из реализации состояния по умолчанию.

После создания ключа мы пытаемся загрузить соответствующее состояние. Затем выполняем все нужные диалоги бота и сохраняем состояние. Если сохранение проходит успешно, мы отправляем накопленные в этом диалоге исходящие действия и завершаем работу. В противном случае возвращаемся назад и повторяем весь процесс, начиная с загрузки данных. Повторная загрузка предоставит нам новое значение ETag, что позволяет надеяться на успешное сохранение при очередной попытке.

В итоге полная реализация OnTurn выглядит следующим образом:

**ScaleoutBot.cs**  
[!code-csharp[OnMessageActivity](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/Bots/ScaleOutBot.cs?range=43-72)]

Обратите внимание на то, что выполнение диалога здесь оформлено как вызов функции. Можно создать и более сложные реализации, определив интерфейс и создав внедряемую зависимость. Но для нашего примера включение диалога в статическую функцию хорошо согласуется с функциональной природой выбранного подхода. В общем случае такая реализация решения, в которой критически важные части становятся функциональными компонентами, станет хорошей основой для успешной работы решения в сетевой среде.


## <a name="implementing-outbound-activity-buffering"></a>Реализация буферизации исходящих действий 

Следующее требование — помещать в буфер все исходящие действия, пока не будет выполнено успешное сохранение. Для этого мы применим пользовательскую реализацию BotAdapter. В этом коде реализована абстрактная функция SendActivity, которая добавляет действие в список вместо немедленной отправки. Это никак не повлияет на размещаемый диалог.
В этом конкретном сценарии не поддерживаются операции UpdateActivity и DeleteActivity. Поэтому эти методы просто создают исключение Not Implemented (Не реализовано). Кроме того, мы не учитываем возвращаемое значение SendActivity. Оно используется некоторыми каналами в таких сценариях, когда нужны обновления действий, например для отключения кнопок в карточках, отображаемых в канале. Обмен такими сообщениями может быть довольно сложным, особенно при отслеживании состояния, и эти сложности выходят за рамки нашей статьи. Полная реализация пользовательского BotAdapter выглядит следующим образом:

**DialogHostAdapter.cs**  
[!code-csharp[DialogHostAdapter](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/DialogHostAdapter.cs?range=19-46)]

## <a name="integration"></a>Интеграция

Теперь нам осталось собрать все составляющие части и подключить их к существующим компонентам платформы. Основной цикл повтора размещен в функции IBot OnTurn. Он содержит пользовательскую реализацию IStore, которую для мы выполнили в виде внедряемой зависимости в целях тестирования. Весь код размещаемого диалога находится в классе с именем DialogHost, который предоставляет одну общедоступную статическую функцию. Эта функция принимает входящее действие и старое значение состояние, а затем возвращают результирующие действия и новое состояние.

В этой функции сначала создается пользовательский объект BotAdapter, который мы описали выше. Затем мы выполняем диалог точно так же, как обычно, создавая DialogSet и DialogContext и реализуя обычный поток с использованием Continue или Begin. Нам осталось рассмотреть только один компонент — пользовательский метод доступа Accessor. По сути, это очень простая оболочка совместимости, которая упрощает передачу состояния диалога в нашу систему обработки. Метод доступа использует семантику ref при работе с системой обработки диалога. Поэтому ему достаточно передать дескриптор. Чтобы рабочий поток был максимально простым, используемый шаблон класса поддерживает только семантику ref.

Мы соблюдаем крайнюю осторожность при расположении слоев. Метод JsonSerialization мы добавим прямо в код размещения, так как не хотим выносить его в подключаемый слой хранилища, разные реализации которого могут использовать разные методы сериализации.

Ниже приведен полный код драйвера.

**DialogHost.cs**  
[!code-csharp[DialogHost](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/DialogHost.cs?range=22-72)]

И, наконец, пользовательский метод доступа реализует только метод Set, так как состояние передается по ссылке:

**RefAccessor.cs**  
[!code-csharp[RefAccessor](~/../botbuilder-samples/samples/csharp_dotnetcore/42.scaleout/RefAccessor.cs?range=22-60)]

## <a name="additional-information"></a>Дополнительная информация
Исходный код примеров для этой статьи на языке [C#](http://aka.ms/scale-out) можно найти на сайте GitHub.

