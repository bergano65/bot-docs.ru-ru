---
title: Реализация процесса общения | Документация Майкрософт
description: Сведения о том, как управлять простым процессом общения с помощью диалогов в пакете SDK Bot Framework.
keywords: simple conversation flow, sequential conversation flow, dialogs, prompts, waterfalls, dialog set
author: JonathanFingold
ms.author: v-jofing
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 05/23/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 680d9148b463bbb5d10f4a6a06cc7b32b824b66e
ms.sourcegitcommit: ea64a56acfabc6a9c1576ebf9f17ac81e7e2a6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/24/2019
ms.locfileid: "66215420"
---
# <a name="implement-sequential-conversation-flow"></a>Реализация процесса общения

[!INCLUDE[applies-to](../includes/applies-to.md)]

Сбор данных путем размещения вопросов — это один из основных способов взаимодействия между ботом и пользователями. Библиотека Dialogs упрощает отправку вопросов и проверку ответов, чтобы убедиться в правильности типов данных или выполнении пользовательских правил проверки.

С помощью библиотеки диалогов можно управлять простыми и сложными процессами общения. В самом простом сценарии взаимодействия бот выполняет фиксированную последовательность действий и завершает диалог. В общем случае диалог нужен для того, чтобы собрать для бота информацию от пользователя. В этом разделе подробно описано, как реализовать простой процесс общения путем создания запросов и их вызова из каскадного диалога. 

## <a name="prerequisites"></a>Предварительные требования

- Понимание [основных принципов работы ботов][concept-basics], [управления состоянием][concept-state] и [библиотеки диалогов][concept-dialogs].
- Копия примера диалога **с несколькими запросами** для [**C#** ][cs-sample] или [**JavaScript**][js-sample].

## <a name="about-this-sample"></a>Об этом примере

В примере диалога с несколькими запросами мы применим каскадный диалог, несколько запросов и компонентный диалог для реализации простого взаимодействия, в рамках которого пользователю предлагается несколько вопросов. Код диалога циклически перебирает следующие действия:

| Действия        | Тип запроса  |
|:-------------|:-------------| 
| Запрос к пользователю о режиме транспортировки | Запрос выбора |
| Запрос имени пользователя | Запрос текста |
| Запрос к пользователю, готов ли он указать свой возраст | Запрос подтверждения |
| Если получен положительный ответ, запрос возраста пользователя  | Запрос числа с проверкой, при которой принимается возраст только в диапазоне от 0 до 150. |
| Запрос на подтверждение собранной информации | Повторный запрос подтверждения |

И наконец, если получен положительный ответ, отображается вся собранная информация. В противном случае пользователь получает сообщение о том, что данные не будут сохранены.

## <a name="create-the-main-dialog"></a>Создание главного диалога

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

Чтобы использовать диалоги, установите пакет NuGet **Microsoft.Bot.Builder.Dialogs**.

Бот взаимодействует с пользователем через `UserProfileDialog`. Когда мы создаем класс `DialogBot` в боте, мы назначаем `UserProfileDialog` главным диалогом. Затем бот применяет вспомогательный метод `Run` для доступа к этому диалогу.

![Диалог о профиле пользователя](media/user-profile-dialog.png)

**Dialogs\UserProfileDialog.cs**

Для начала мы создадим `UserProfileDialog`, наследуемый от класса `ComponentDialog`, в котором будет шесть шагов.

В конструкторе `UserProfileDialog` создайте каскадные шаги, запросы и каскадный диалог, затем добавьте их в набор диалогов. Запросы должны находиться в том же наборе диалогов, в котором они используются.

[!code-csharp[Constructor snippet](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=22-41)]

Затем мы реализуем действия, которые использует диалог. Чтобы использовать запрос, вызовите его из любого шага диалога и получите результат на следующем шаге с помощью `stepContext.Result`. Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса, пока не будут получены допустимые данные.

Из каскадного шага следует всегда возвращать ненулевое значение `DialogTurnResult`. Без этого диалог может работать неправильно. Здесь мы покажем реализацию `NameStepAsync` в каскадном диалоге.

[!code-csharp[Name step](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=56-61)]

В `AgeStepAsync` мы укажем строку повторного запроса для тех случаев, когда входные данные не пройдут проверку из-за неправильного формата для анализа или несоответствия критерию проверки для конкретного запроса. Если строка повторного запроса не указана, в таких случаях пользователю будет повторно предоставляться исходный текст запроса для получения входных данных.

[!code-csharp[Age step](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=74-93&highlight=10)]

**UserProfile.cs**

Режим транспортировки, имя и возраст пользователя сохраняются в экземпляре класса `UserProfile`.

[!code-csharp[UserProfile class](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/UserProfile.cs?range=9-16)]

**Dialogs\UserProfileDialog.cs**

На последнем шаге мы проверяем значение `stepContext.Result`, возвращенное диалогом, который мы вызвали на предыдущем каскадном шаге. Если возвращаемое значение равно TRUE, мы используем метод доступа для профиля пользователя, чтобы получить и обновить профиль пользователя. Чтобы получить профиль пользователя, мы вызовем метод `GetAsync`, а затем зададим новые значения свойств `userProfile.Transport`, `userProfile.Name` и `userProfile.Age`. Наконец, мы сообщим пользователю сводку данных и вызовем метод `EndDialogAsync` для завершения диалога. Завершенный диалог удаляется из стека диалогов, а его результат (если есть) возвращается в родительский диалог. Родительским считается диалог или метод, в котором был запущен только что завершившийся диалог.

[!code-csharp[SummaryStepAsync](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Dialogs/UserProfileDialog.cs?range=108-134&highlight=5-10,25-26)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

Чтобы использовать диалоги, в проект следует установить пакет npm **botbuilder-dialogs**.

Бот взаимодействует с пользователем через `UserProfileDialog`. Когда мы создаем `DialogBot` в боте, мы назначаем `UserProfileDialog` главным диалогом. Затем бот применяет вспомогательный метод `run` для доступа к этому диалогу.

![Диалог о профиле пользователя](media/user-profile-dialog-js.png)

**dialogs\userProfileDialog.js**

Для начала мы создадим `UserProfileDialog`, наследуемый от класса `ComponentDialog`, в котором будет шесть шагов.

В конструкторе `UserProfileDialog` создайте каскадные шаги, запросы и каскадный диалог, затем добавьте их в набор диалогов. Запросы должны находиться в том же наборе диалогов, в котором они используются.

[!code-javascript[Constructor snippet](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=25-47)]

Затем мы реализуем действия, которые использует диалог. Чтобы использовать запрос, вызовите его из любого шага диалога и получите результат из контекста шага на следующем шаге. Здесь для этого используется `step.result`. Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса, пока не будут получены допустимые данные.

Из каскадного шага следует всегда возвращать ненулевое значение `DialogTurnResult`. Без этого диалог может работать неправильно. Здесь мы покажем реализацию `nameStep` в каскадном диалоге.

[!code-javascript[name step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=75-78)]

В `ageStep` мы укажем строку повторного запроса для тех случаев, когда входные данные не пройдут проверку из-за неправильного формата для анализа или несоответствия критерию проверки, который указан выше в конструкторе, для конкретного запроса. Если строка повторного запроса не указана, в таких случаях пользователю будет повторно предоставляться исходный текст запроса для получения входных данных.

[!code-javascript[age step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=90-101&highlight=5)]

**userProfile.js**

Режим транспортировки, имя и возраст пользователя сохраняются в экземпляре класса `UserProfile`.

[!code-javascript[user profile](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/userProfile.js?range=4-10)]

**Dialogs\UserProfileDialog.cs**

На последнем шаге мы проверяем значение `step.result`, возвращенное диалогом, который мы вызвали на предыдущем каскадном шаге. Если возвращаемое значение равно TRUE, мы используем метод доступа для профиля пользователя, чтобы получить и обновить профиль пользователя. Чтобы получить профиль пользователя, мы вызовем метод `get`, а затем зададим новые значения свойств `userProfile.transport`, `userProfile.name` и `userProfile.age`. Наконец, мы сообщим пользователю сводку данных и вызовем метод `endDialog` для завершения диалога. Завершенный диалог удаляется из стека диалогов, а его результат (если есть) возвращается в родительский диалог. Родительским считается диалог или метод, в котором был запущен только что завершившийся диалог.

[!code-javascript[summary step](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=115-136&highlight=4-8,20-21)]

---

## <a name="create-the-extension-method-to-run-the-waterfall-dialog"></a>Создание метода расширения для запуска каскадного диалога

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

Мы определили метод расширения `Run`, который будет использоваться для создания контекста диалога и доступа к нему. Здесь `accessor` является методом доступа к свойству состояния для диалога, а `dialog` — это компонентный диалог для профиля пользователя. Так как компонентные диалоги определяют набор внутренних диалогов, нам следует создать внешний набор диалогов, доступный для кода обработчика сообщений, чтобы использовать его для создания контекста диалога.

Контекст диалога создается путем вызова метода `CreateContext` и используется для взаимодействия с набором диалогов в обработчике шагов бота. Контекст диалога содержит сведения о текущем шаге, о родительском диалоге, а также состояние диалога для сохранения данных в ходе диалога.

Контекст диалога позволяет начать диалог по идентификатору строки или продолжить текущий диалог (например, выполнить очередной шаг каскадного диалога). Контекст диалога передается через все диалоги и каскадные действия бота.

**DialogExtensions.cs**

[!code-csharp[Run method](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/DialogExtensions.cs?range=13-24)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

Мы определили вспомогательный метод `run` внутри `userProfileDialog`, который будет использоваться для создания контекста диалога и доступа к нему. Здесь `accessor` является методом доступа к свойству состояния для диалога, а `this` — это компонентный диалог для профиля пользователя. Так как компонентные диалоги определяют набор внутренних диалогов, нам следует создать внешний набор диалогов, доступный для кода обработчика сообщений, чтобы использовать его для создания контекста диалога.

Контекст диалога создается путем вызова метода `createContext` и используется для взаимодействия с набором диалогов в обработчике шагов бота. Контекст диалога содержит сведения о текущем шаге, о родительском диалоге, а также состояние диалога для сохранения данных в ходе диалога.

Контекст диалога позволяет начать диалог по идентификатору строки или продолжить текущий диалог (например, выполнить очередной шаг каскадного диалога). Контекст диалога передается через все диалоги и каскадные действия бота.

[!code-javascript[run method](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/dialogs/userProfileDialog.js?range=55-64)]

---

## <a name="run-the-dialog"></a>Запуск диалога

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

**Bots\DialogBot.cs**

Обработчик `OnMessageActivityAsync` использует метод расширения, чтобы начать или продолжить диалог. В `OnTurnAsync` мы используем объекты управления состоянием бота, чтобы передать в хранилище любые изменения состояния. (Метод `ActivityHandler.OnTurnAsync` вызывает разные методы обработки действий, например `OnMessageActivityAsync`. Это позволяет сохранить состояние после того, как обработчик сообщений завершит работу, но раньше завершения самого шага.)

[!code-csharp[overrides](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Bots/DialogBot.cs?range=33-48&highlight=5-7)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

Обработчик `onMessage` использует вспомогательный метод, чтобы начать или продолжить диалог. В `onDialog` мы используем объекты управления состоянием бота, чтобы передать в хранилище любые изменения состояния. (Метод `onDialog` вызывается последним, после выполнения всех остальных определенных обработчиков, таких как `onMessage`. Это позволяет сохранить состояние после того, как обработчик сообщений завершит работу, но раньше завершения самого шага.)

[!code-javascript[overrides](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/bots/dialogBot.js?range=30-44)]

---

## <a name="register-services-for-the-bot"></a>Регистрация служб для бота

Этот бот использует следующие _службы_.

- Основные службы бота: поставщик учетных данных, адаптер и реализация бота.
- Службы для управления состоянием: хранилище, состояние пользователя и состояние беседы.
- Диалог, который будет использовать бот.

# <a name="ctabcsharp"></a>[C#](#tab/csharp)

**Startup.cs.**

В `Startup` мы регистрируем службы для бота. Эти службы доступны в других частях кода через механизм внедрения зависимостей.

[!code-csharp[ConfigureServices](~/../botbuilder-samples/samples/csharp_dotnetcore/05.multi-turn-prompt/Startup.cs?range=17-41)]

# <a name="javascripttabjavascript"></a>[JavaScript](#tab/javascript)

**index.js**

В `index.js` мы регистрируем службы для бота. 

[!code-javascript[overrides](~/../botbuilder-samples/samples/javascript_nodejs/05.multi-turn-prompt/index.js?range=18-49)]

---

> [!NOTE]
> Хранилище в памяти используется только для тестирования и не предназначено для рабочей среды.
> Для ботов в рабочей среде обязательно используйте постоянное хранилище любого типа.

## <a name="to-test-the-bot"></a>Тестирование бота

1. Установите [Bot Framework Emulator](https://aka.ms/bot-framework-emulator-readme), если вы этого еще не сделали.
1. Выполните этот пример на локальном компьютере.
1. Запустите эмулятор, подключитесь к боту и отправьте несколько сообщений, как показано ниже.

![Тестовый запуск диалога с несколькими запросами](../media/emulator-v4/multi-turn-prompt.png)

## <a name="additional-information"></a>Дополнительная информация

### <a name="about-dialog-and-bot-state"></a>Сведения о диалоге и состоянии бота

В этом боте мы определили два метода доступа к свойству состояния.

- Один из них создается в состоянии беседы для свойства состояния диалога. Состояние диалога отслеживает позицию пользователя в наборе диалогов. Это свойство обновляется контекстом диалога, например при вызове методов begin dialog или continue dialog.
- Второй создается в состоянии пользователя для свойства профиля пользователя. Бот использует этот метод для отслеживания сведений о пользователе. Мы управляем этим состоянием прямо в коде диалога.

Методы доступа _get_ и _set_ для свойства состояния позволяют получить и сохранить значение этого свойства в кэше объекта управления состоянием. Кэш заполняется автоматически при первом обращении к значению свойства состояния в течение шага, но сохранять его нужно явным образом. Чтобы сохранить изменения в обоих свойствах состояния, мы вызываем метод _save changes_ для соответствующего объекта управления состоянием.

В этом примере обновляется состояние профиля пользователя из диалога. Такой подход допустим для простого бота, но не позволит повторно использовать этот диалог в другом боте.

Есть несколько подходов, позволяющих отделить этапы диалога от состояний бота. Например, после сбора информации вы можете сделать следующее:

- Выполните метод end dialog, чтобы передать собранные данные в виде возвращаемого значения обратно в контекст родительского элемента. Это может быть обработчик шагов бота или предыдущий активный диалог из стека диалогов. Именно так разрабатываются классы запросов.
- Создайте запрос к соответствующей службе. Это может быть хорошим вариантом, если бот выступает в роли интерфейса для более крупной службы.

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Добавление возможности распознавания естественного языка в функционал бота](bot-builder-howto-v4-luis.md)

<!-- Footnote-style links -->

[concept-basics]: bot-builder-basics.md
[concept-state]: bot-builder-concept-state.md
[concept-dialogs]: bot-builder-concept-dialog.md

[prompting]: bot-builder-prompts.md
[component-dialogs]: bot-builder-compositcontrol.md

[cs-sample]: https://aka.ms/cs-multi-prompts-sample
[js-sample]: https://aka.ms/js-multi-prompts-sample
