---
title: Включение проверки подлинности для бота с помощью службы Azure Bot — Служба Azure Bot
description: Сведения об использовании функции проверки подлинности службы Azure Bot для добавления боту функции единого входа.
ms.author: kamrani
manager: kamrani
ms.topic: article
ms.service: bot-service
ROBOTS: NOINDEX
ms.date: 11/14/2019
monikerRange: azure-bot-service-3.0
ms.openlocfilehash: aab49803939a42974a59b66f47a1f004019421b4
ms.sourcegitcommit: 4e1af50bd46debfdf9dcbab9a5d1b1633b541e27
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/25/2020
ms.locfileid: "76752786"
---
# <a name="add-authentication-to-your-bot-via-azure-bot-service"></a>Добавление проверки подлинности к боту с помощью службы Azure Bot

[!INCLUDE [pre-release-label](includes/pre-release-label-v3.md)]  

В этом руководстве используются функции бота проверки подлинности службы Azure Bot. Они упрощают разработку бота, который выполняет проверку подлинности пользователей в различных поставщиках удостоверений, например Azure AD (Azure Active Directory), GitHub, Uber и т. д. Также эти обновления помогают улучшить взаимодействие с пользователем путем устранения _проверки шифра_ для некоторых клиентов.

До этого бот должен включать контроллеры OAuth и ссылки для входа, хранить целевые идентификаторы и секреты клиента и выполнять управление токенами пользователей.
<!--
These capabilities were bundled in the BotAuth and AuthBot samples that are on GitHub.
-->

Теперь разработчикам ботов больше не нужно размещать контроллеры OAuth или управлять жизненным циклом токена, так как все это может выполнять служба Azure Bot.

Доступны следующие функции:

- Усовершенствования каналов поддержки новых функций проверки подлинности, таких как новые библиотеки WebChat и DirectLineJS, позволяют устранить необходимость в шестизначной проверке шифра.
- Усовершенствования портала Azure по добавлению, удалению и настройке параметров подключения к различным поставщикам удостоверений OAuth.
- Поддержка множества встроенных поставщиков удостоверений, включая Azure AD (конечные точки версий 1 и 2), GitHub и другие.
- Обновления пакетов SDK Bot Framework для C# и Node.js, которые дают возможность извлекать токены, создавать OAuthCards и обрабатывать события TokenResponse.
- Примеры того, как сделать бота, который выполняет проверку подлинности для Azure AD (конечные точки версий 1 и 2) и GitHub.

Чтобы добавить к существующему боту следующие функции, можно экстраполировать шаги, описанные в этой статье. Далее приведены примеры ботов, которые демонстрируют новые функции проверки подлинности.

| Образец | Версия Bot Builder | Описание |
|:---|:---:|:---|
| [AadV1Bot](https://aka.ms/AadV1Bot) | Версия 3 | Реализована поддержка OAuthCard в пакете SDK версии 3 для C# с помощью конечной точки Azure AD версии 1 |
| [AadV2Bot](https://aka.ms/AadV2Bot) | Версия 3 |  Реализована поддержка OAuthCard в пакете SDK версии 3 для C# с помощью конечной точки Azure AD версии 2 |
| [GitHubBot](https://aka.ms/GitHubBot) | Версия 3 |  Реализована поддержка OAuthCard в пакете SDK версии 3 для C# с помощью GitHub |
| [BasicOAuth](https://aka.ms/BasicOAuth) | Версия 3 |  Реализована поддержка OAuth 2.0 в пакете SDK версии 3 для C# |

> [!NOTE]
> Функции проверки подлинности также работают с Node.js в Bot Builder версии 3. Однако в этой статье рассматривается только пример кода, написанный на C#.

Дополнительные сведения и поддержку можно найти в статье [Bot Framework additional resources](https://docs.microsoft.com/azure/bot-service/bot-service-resources-links-help) (Дополнительные ресурсы Bot Framework).

## <a name="overview"></a>Обзор

В этом руководстве создается пример бота, который подключается к Microsoft Graph, с помощью токена Azure AD версии 1 или 2. <!--verify this info and fix wording--> Для этого процесса используется код из репозитория GitHub. В этом руководстве есть инструкции по его настройке, включая настройку приложения бота.

- [Создание бота и приложения проверки подлинности](#create-your-bot-and-an-authentication-application)
- [Подготовка примера кода бота](#prepare-the-bot-sample-code)
- [Подключение эмулятора Bot Framework для проверки бота](#use-the-emulator-to-test-your-bot)

Для выполнения этих действий потребуются установленные Visual Studio 2017, Npm, Node.js и Git. Также необходимо обладать некоторым опытом работы с Azure, OAuth 2.0 и разработки ботов.

После завершения появится бот, который может выполнить несколько простых задач в приложении Azure AD, например он может проверять и отправлять электронную почту или отображать пользователя и менеджера. Чтобы это сделать, бот будет использовать токен приложения Azure AD библиотеки Microsoft.Graph.

В заключительной части статьи рассматриваются некоторые примеры кодов бота.

- [Примечания о потоке извлечения токена](#notes-on-the-token-retrieval-flow)

## <a name="create-your-bot-and-an-authentication-application"></a>Создание бота и приложения проверки подлинности

Вам нужно создать бот регистрации, в конечную точку обмена сообщениями которого будет отправляться код развернутого бота, а также создать приложение Azure AD (версии 1 или 2), чтобы позволить боту получить доступ к Office 365.

> [!NOTE]
> Данные функции проверки подлинности работают с другими типами ботов. Тем не менее в этом руководстве используется только бот регистрации.

### <a name="register-an-application-in-azure-ad"></a>Регистрация приложение в Azure AD

Вам потребуется приложение Azure AD, которое бот сможет использовать в качестве поставщика удостоверений для подключения к API Microsoft Graph.

Для данного бота можно использовать конечные точки Azure AD версии 1 или 2.
Дополнительные сведения о разнице между конечными точками версии 1 и 2 см. в статьях [What's different about the v2.0 endpoint?](https://docs.microsoft.com/azure/active-directory/develop/active-directory-v2-compare) (Что нового в конечной точке версии 2.0 ) и [Настройка входа пользователей с помощью учетной записи Майкрософт и Azure Active Directory в одном приложении](https://docs.microsoft.com/azure/active-directory/develop/active-directory-appmodel-v2-overview).

#### <a name="create-an-azure-ad-identity-provider-application"></a>Создание приложения поставщика удостоверений Azure AD 

Эта процедура позволяет создать приложение AAD. Созданное приложение можно использовать с конечными точками версии 1 или 2.

> [!TIP]
> Вам понадобится создать и зарегистрировать приложение Azure AD в клиенте, в котором можно дать согласие на делегирование разрешений, запрошенных приложением.

1. Откройте панель [Azure Active Directory][azure-aad-blade] на портале Azure.
    Если вы не попадете сразу в нужный арендатор, щелкните действие **Переключить каталог**. (См. инструкции по [созданию арендатора с помощью портала](https://docs.microsoft.com/azure/active-directory/fundamentals/active-directory-access-create-new-tenant).)
1. Откройте панель **Регистрация приложений**.
1. На панели **Регистрация приложений** щелкните **Новая регистрация**.
1. Заполните обязательные поля и создайте регистрацию приложения.

   1. Присвойте имя приложению.
   1. Выберите **Поддерживаемые типы учетных записей** для приложения.
   1. Для **URI перенаправления**:
       1. Выберите **Интернет**.
       1. Укажите для URL-адреса значение `https://token.botframework.com/.auth/web/redirect`.
   1. Щелкните **Зарегистрировать**.

      - После создания в Azure отображается страница **Обзор** для приложения.
      - Запишите **идентификатор приложения (клиента)** . Это значение вам нужно будет ввести позднее в поле _Идентификатор клиента_ при регистрации приложения AAD в боте.
      - Также запишите **идентификатор каталога (арендатора)** . Вы будете использовать эти значения для регистрации приложения с ботом.
 
    > [!NOTE]
    > Если для поддерживаемых типов учетных записей указано значение "Один клиент" и вы используете личную подписку, а не учетную запись Майкрософт, эмулятор выдаст ошибку: *The bot's Microsoft App ID or Microsoft App Password is incorrect…* (Неверный идентификатор приложения Майкрософт для бота или пароль приложения Майкрософт…) В этом случае для поддерживаемых типов учетных записей нужно указать *Учетные записи в любом каталоге организации (любой каталог Azure AD — мультитенантный) и персональные учетные записи Майкрософт (например, Skype, Xbox)* .

1. В области навигации щелкните **Сертификаты и секреты**, чтобы создать секрет для приложения.

   1. В разделе **Секреты клиента** щелкните **New client secret** (Новый секрет клиента).
   1. Добавьте описание, чтобы отличать этот секрет от других секретов, которые могут вам понадобиться для создания этого приложения, включая `bot login`.
   1. Задайте для параметра **Срок действия истекает** значение **Никогда**.
   1. Нажмите кнопку **Добавить**.
   1. Перед закрытием этой страницы запишите секрет. Это значение вам нужно будет ввести позднее в поле _Секрет клиента_ при регистрации приложения AAD в боте.

1. В области навигации щелкните **Разрешения API**, чтобы открыть панель **Разрешения API**. Рекомендуется явно задать разрешения API для приложения.

   1. Щелкните **Добавить разрешение**, чтобы отобразить область **Запрос разрешений API**.
   1. Для этого примера выберите **API Microsoft** и **Microsoft Graph**.
   1. Выберите **Делегированные разрешения** и убедитесь, что выбраны все разрешения, требуемые для этого примера.

      > [!NOTE]
      > Для любого разрешения, отмеченного как **Требуется согласие администратора**, необходимо, чтобы пользователь и администратор клиента вошли в систему. Поэтому для бота лучше использовать поменьше разрешений такого типа.

      - **openid**
      - **profile**
      - **Mail.Read**
      - **Mail.Send**
      - **User.Read**
      - **User.ReadBasic.All**

   1. Щелкните **Добавить разрешения**. (При первом обращении пользователя к этому приложению через бота требуется предоставить согласие.)

Теперь приложение Azure AD настроено.

### <a name="create-your-bot-on-azure"></a>Создание бота в Azure

Создайте **Bot Channels Registration** (Бот регистрации каналов) с помощью [портала Azure](https://portal.azure.com/).

### <a name="register-your-azure-ad-application-with-your-bot"></a>Регистрация в боте приложения Azure AD

Следующим шагом является регистрация приложения Azure AD в созданном боте.

# <a name="azure-ad-v1tabaadv1"></a>[Azure AD версии 1](#tab/aadv1)

1. На [портале Azure](https://portal.azure.com/) перейдите к странице ресурса бота.
1. Щелкните **Параметры**.
1. В разделе **OAuth Connection Settings** (Параметры подключения OAuth), который находится в нижней части страницы, щелкните **Добавить настройку**.
1. Заполните форму следующим образом.

    1. В поле **Имя** введите имя подключения, которое будет затем использовано в коде бота.
    1. В разделе **Поставщик службы** выберите **Azure Active Directory**. После выбора этого параметра появятся отдельные поля Azure AD.
    1. В поле **Идентификатор клиента** введите идентификатор приложения (клиента), который вы записали для приложения Azure AD версии 1.
    1. В поле **Секрет клиента**, введите секрет, который вы создали для предоставления боту доступа к приложению Azure AD.
    1. В поле **Тип предоставления разрешения** введите `authorization_code`.
    1. В поле **URL-адрес входа** введите `https://login.microsoftonline.com`.
    1. В поле **Идентификатор арендатора** введите идентификатор каталога (арендатора), который вы записали для приложения Azure AD.

       Данный клиент будет связан с пользователями, которые могут пройти проверку подлинности.

    1. В поле **URL-адрес ресурса** введите `https://graph.microsoft.com/`.
    1. Оставите поле **Области** пустым.

1. Выберите команду **Сохранить**.

> [!NOTE]
> Используя API Microsoft Graph, эти значения позволяют приложению получать доступ к данным Office 365.

# <a name="azure-ad-v2tabaadv2"></a>[Azure AD версии 2](#tab/aadv2)

1. Перейдите к странице регистрации каналов бота на [портале Azure](https://portal.azure.com/).
1. Щелкните **Параметры**.
1. В разделе **OAuth Connection Settings** (Параметры подключения OAuth), который находится в нижней части страницы, щелкните **Добавить настройку**.
1. Заполните форму следующим образом.

    1. В поле **Имя** введите имя подключения, которое было использовано в коде бота.
    1. В разделе **Поставщик службы** выберите **Azure Active Directory v2**. После выбора этого параметра появятся отдельные поля Azure AD.
    1. В поле **Идентификатор клиента** введите идентификатор приложения (клиента), который вы записали для приложения Azure AD версии 1.
    1. В поле **Секрет клиента**, введите секрет, который вы создали для предоставления боту доступа к приложению Azure AD.
    1. В поле **Идентификатор арендатора** введите идентификатор каталога (арендатора), который вы записали для приложения Azure AD.

       Данный клиент будет связан с пользователями, которые могут пройти проверку подлинности.

    1. В поле **Области** введите имя разрешения, которое было выбрано при регистрации приложения `Mail.Read Mail.Send openid profile User.Read User.ReadBasic.All`.

        > [!NOTE]
        > Для приложения Azure AD версии 2 в поле **Области** можно вносить списки значений, которые являются чувствительными к регистру и разделенные пробелами.

1. Выберите команду **Сохранить**.

> [!NOTE]
> Используя API Microsoft Graph, эти значения позволяют приложению получать доступ к данным Office 365.

---

#### <a name="to-test-your-connection"></a>Тестирование подключения

1. Откройте созданное подключение.
1. Щелкните **Проверка подключения** в верхней части области **Service Provider Connection Setting** (Параметры подключения поставщика службы).
1. При выполнении данного действия в первый раз должна открыться новая вкладка браузера с перечисленными разрешениями, которые запрашивает приложение, и предложение их принять.
1. Нажмите кнопку **Принимаю**.
1. Данное действие перенаправляет пользователя на страницу **Проверка подключения к <your-connection-name> успешно выполнена** .

## <a name="prepare-the-bot-sample-code"></a>Подготовка примера кода бота

1. Клонируйте репозиторий GitHub в https://github.com/Microsoft/BotBuilder.
1. Откройте и создайте решение `BotBuilder\CSharp\Microsoft.Bot.Builder.sln`.
1. Закройте решение и откройте `BotBuilder\CSharp\Samples\Microsoft.Bot.Builder.Samples.sln`.
1. Установите данный проект в качестве проекта запуска.
    - Для бота, который использует приложение Azure AD версии 1, используйте проект `Microsoft.Bot.Sample.AadV1Bot`.
    - Для бота который использует приложение Azure AD версии 2, используйте проект `Microsoft.Bot.Sample.AadV2Bot`.
1. Откройте файл `Web.config` и измените параметры приложения следующим образом.
    1. Установите значение, используемое при настройке параметра подключения бота OAuth 2.0, в качестве параметра `ConnectionName`.
    1. Установите идентификатор приложения в качестве значения параметра `MicrosoftAppId`.
    1. Установите секрет бота в качестве значения параметра `MicosoftAppPassword`.

    > [!IMPORTANT]
    > В зависимости от символов, находящихся в секрете, может потребоваться сменить пароль для XML. Например, символ амперсанда (&) потребуется кодировать как `&amp;`.

    ```xml
    <appSettings>
        <add key="ConnectionName" value="<your-AAD-connection-name>"/>
        <add key="MicrosoftAppId" value="<your-bot-appId>" />
        <add key="MicrosoftAppPassword" value="<your-bot-password>" />
    </appSettings>
    ```

    Если вы не знаете, как получить значения для **идентификатора приложения Майкрософт** и **пароля приложения Майкрософт**, вы можете создать новый пароль, как описано здесь: [Пароль службы "Регистрация каналов бота"](bot-service-quickstart-registration.md#get-registration-password) Или получите **идентификатор приложения Майкрософт** и **пароль приложения Майкрософт**, предоставляемые при **регистрации каналов бота**, из развертывания, как описано здесь: [Find Your Azure Bot’s AppID and AppSecret](https://blog.botframework.com/2018/07/03/find-your-azure-bots-appid-and-appsecret) (Поиск идентификатора и секрета приложения для бота Azure)

    > [!NOTE]
    > Теперь код бота можно опубликовать в подписке Azure (щелкните проект правой кнопкой мыши и выберите **Опубликовать**), но это действие необязательно для текущего руководства. Необходимо будет настроить конфигурацию публикации, которая использует план приложения и размещения, который использовался при настройке бота на портале Azure.

## <a name="use-the-emulator-to-test-your-bot"></a>Подключение эмулятора Bot Framework для проверки бота

Для локальной проверки бота требуется установить [Bot Emulator](https://github.com/Microsoft/BotFramework-Emulator). Можно использовать Bot Framework Emulator версии 3 или 4.

1. Запустите бот (с отладкой или без).
1. Запишите номер порта localhost страницы. Данная информация потребуется для взаимодействия с ботом.
1. Запустите эмулятор Bot Framework.
1. Подключитесь к боту.

   Если подключение еще не было настроено, необходимо предоставить адрес, а также идентификатор приложения Майкрософт и пароль для бота. К каждому из URL-адресов требуется добавить `/api/messages`. URL-адрес должен выглядеть примерно так: `http://localhost:portNumber/api/messages`.

1. Чтобы просмотреть список доступных команд для бота и проверить функции проверки подлинности, введите `help`.
1. После выполнения входа и до момента выхода не требуется повторно предоставлять учетные данные.
1. Чтобы выйти и отменить проверку подлинности, введите `signout`.

<!--To restart completely from scratch you also need to:
1. Navigate to the **AppData** folder for your account.
1. Go to the **Roaming/botframework-emulator** subfolder.
1. Delete the **Cookies** and **Coolies-journal** files.
-->

> [!NOTE]
> Для использования проверки подлинности бота требуется служба Bot Connector. Служба получает доступ к сведениям о боте регистрации каналов, поэтому на портале требуется установить конечную точку обмена сообщениями бота. Для проверки подлинности также требуется использовать протокол HTTPS. Поэтому для бота, запущенного локально, необходимо создать адрес перенаправления HTTPS.

<!--The following is necessary for WebChat:
1. Use the **ngrok** command-line tool to get a forwarding HTTPS address for your bot.
   - For information on how to do this, see [Debug any Channel locally using ngrok](https://blog.botframework.com/2017/10/19/debug-channel-locally-using-ngrok/).
   - Any time you exit **ngrok**, you will need to redo this and the following step before starting the Emulator.
1. On the Azure Portal, go to the **Settings** blade for your bot.
   1. In the **Configuration** section, change the **Messaging endpoint** to the HTTPS forwarding address generated by **ngrok**.
   1. Click **Save** to save your change.
-->

## <a name="notes-on-the-token-retrieval-flow"></a>Примечания о потоке извлечения токена

Когда пользователь приказывает боту выполнить некоторые действия, которые требуют пользовательского входа, бот может использовать `Microsoft.Bot.Builder.Dialogs.GetTokenDialog`, чтобы инициировать извлечение токена для данного соединения. Следующие несколько фрагментов кода были взяты из класса `GetTokenDialog`.

### <a name="check-for-a-cached-token"></a>Проверка кэшированного токена

Как видно из этого кода, сначала бот выполняет быструю проверку, чтобы определить, имеет ли служба Azure Bot токен пользователя (который идентифицирован текущим отправителем действия) и полученное ConnectionName (которое является именем подключения, используемое в конфигурации). К этому моменту служба Azure Bot уже будет обладать кэшированным токеном (или не будет). Эту быструю проверку можно выполнить с помощью вызова метода GetUserTokenAsync. Если служба Azure Bot имеет токен и возвращает его, он может быть использован мгновенно. Если служба Azure Bot не имеет токена, результатом выполнения этого метода будет NULL. В таком случае бот может отправить пользователю для входа настраиваемый OAuthCard.

```csharp
// First ask Bot Service if it already has a token for this user
var token = await context.GetUserTokenAsync(ConnectionName).ConfigureAwait(false);
if (token != null)
{
    // use the token to do exciting things!
}
else
{
    // If Bot Service does not have a token, send an OAuth card to sign in
    await SendOAuthCardAsync(context, (Activity)context.Activity);
}
```

### <a name="send-an-oauthcard-to-the-user"></a>Отправка OAuthCard пользователю

Для настраивания OAuthCard можно использовать любой текст и текст кнопки. Ниже приведены важные действия, которые необходимо выполнить.

- Измените `ContentType` на `OAuthCard.ContentType`.
- Замените значение свойства `ConnectionName` на имя требуемого подключения.
- Включите одну кнопку с действием `CardAction` (`Type` `ActionTypes.Signin`). Обратите внимание, что для ссылки для входа не требуется указывать какие-либо значения.

В конце вызова боту требуется подождать на "возвращение токена". Ожидание происходит в основной ленте активности, потому что для входа в систему может потребоваться много времени.

```csharp
private async Task SendOAuthCardAsync(IDialogContext context, Activity activity)
{
    await context.PostAsync($"To do this, you'll first need to sign in.");

    var reply = await context.Activity.CreateOAuthReplyAsync(_connectionName, _signInMessage, _buttonLabel).ConfigureAwait(false);
    await context.PostAsync(reply);

    context.Wait(WaitForToken);
}
```

### <a name="wait-for-a-tokenresponseevent"></a>Ожидание метода TokenResponseEvent

В данном коде класс диалога бота ожидает `TokenResponseEvent` (дополнительные сведения о том, как данный метод перенаправляется в стек Диалога, приведены ниже). Метод `WaitForToken` сначала определяет, было ли это отправлено. Если да, то оно может быть использовано ботом. Если нет, метод `WaitForToken` принимает любой текст, отправленный боту, и передает его `GetUserTokenAsync`. Данное действие выполняется, потому что клиенту (например WebChat) не требуется код проверки подлинности шифра, и он может напрямую отсылать маркер в `TokenResponseEvent`. Другие клиенты (например Facebook или Slack) все еще требуют шифр. Служба Azure Bot представит этим клиентам шестизначный шифр и попросит пользователя ввести его в окно чата. Это не оптимальное решение, но оно применяется в качестве резервного. Таким образом, если `WaitForToken` получает код, бот может отправить его в службу Azure Bot и получить маркер. Если данный вызов также потерпит неудачу, пользователь может принять решение об отправке отчета об ошибке, или выполнить другое действие. В большинстве случаев бот получит токен пользователя.

Если посмотреть файл **MessageController.cs**, то можно увидеть, что действия `Event` такого типа перенаправляются в стек диалогового окна.

```csharp
private async Task WaitForToken(IDialogContext context, IAwaitable<object> result)
{
    var activity = await result as Activity;

    var tokenResponse = activity.ReadTokenResponseContent();
    if (tokenResponse != null)
    {
        // Use the token to do exciting things!
    }
    else
    {
        if (!string.IsNullOrEmpty(activity.Text))
        {
            tokenResponse = await context.GetUserTokenAsync(ConnectionName,
                                                               activity.Text);
            if (tokenResponse != null)
            {
                // Use the token to do exciting things!
                return;
            }
        }
        await context.PostAsync($"Hmm. Something went wrong. Let's try again.");
        await SendOAuthCardAsync(context, activity);
    }
}
```

### <a name="message-controller"></a>Контроллер сообщений

При последующих вызовах бота обратите внимание, что этот токен никогда не кэшируется ботом из этого примера. Это связано с тем, что бот всегда может запросить токен в службе Azure Bot. Это позволяет избежать того, что боту необходимо управлять жизненным циклом токена, обновлять токен и т. д., поскольку служба Azure Bot делает все это сама.

```csharp
else if(message.Type == ActivityTypes.Event)
{
    if(message.IsTokenResponseEvent())
    {
        await Conversation.SendAsync(message, () => new Dialogs.RootDialog());
    }
}
```
## <a name="additional-resources"></a>Дополнительные ресурсы
[Пакет SDK Bot Framework](https://github.com/microsoft/botbuilder)
