---
title: Диалоги в пакете SDK Bot Framework | Документация Майкрософт
description: Сведения о диалоге и его использовании в пакете SDK Bot Framework.
keywords: conversation flow, prompt, dialog state, recognize intent, single turn, multiple turn, bot conversation, dialogs, prompts, waterfalls, dialog set
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 05/23/2019
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 3f726587c02315a1d2c0d7910fafabbd4577c73d
ms.sourcegitcommit: ea64a56acfabc6a9c1576ebf9f17ac81e7e2a6b7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/24/2019
ms.locfileid: "66215508"
---
# <a name="dialogs-library"></a>Библиотека диалогов

[!INCLUDE [applies-to-v4](../includes/applies-to.md)]

*Диалоги* являются важнейшим компонентом в этом пакете SDK. Это способ управления беседой с пользователем. Диалогами называются структуры, которые выполняют в программе бота роль функций. Каждый диалог проектируется так, чтобы выполнять определенную задачу в определенном порядке. Вы можете указать порядок отдельных диалогов для управления беседой и использовать разные механизмы их вызова: в ответ на сообщение пользователя или внешние события либо по команде из других диалогов.

Библиотека диалогов предоставляет ряд встроенных функций, например *запросы* и *каскадные диалоги*, которые упрощают управление беседой в боте. [Запросы](#prompts) позволяют получать данные разных типов, например тексты, числа или даты. [Каскадные диалоги](#waterfall-dialogs) позволяют объединить несколько шагов в последовательность, в соответствии с которой бот будет передавать информацию следующему шагу.

<!-- When we have samples for building your own, add links and one liner about them -->

## <a name="dialogs-and-their-pieces"></a>Диалоги и отдельные компоненты

Библиотека диалогов содержит несколько дополнительных компонентов для повышения полезности. Кроме разных [типов диалогов](#dialog-types), которые описаны ниже, в библиотеке реализованы концепции *набора диалогов*, *контекста диалога* и *результата диалога*.

*Набором диалогов* в простейшем случае называется коллекция диалогов. В нее могут включаться разные объекты, например запросы, каскадные диалоги и (или) [компонентные диалоги](#component-dialog). Каждый из компонентов является реализацией диалога и имеет конкретный идентификатор строки в наборе диалогов. Когда боту потребуется некоторый диалог или запрос из набора диалогов, он указывает идентификатор строки для нужного компонента.

*Контекст диалога* содержит некоторые сведения о диалоге и позволяет взаимодействовать с набором диалогов из обработчика шагов диалога, реализованного в боте. Контекст диалога содержит сведения о текущем шаге, о родительском диалоге, а также [состояние диалога](#dialog-state) для сохранения данных в ходе диалога. Контекст диалога позволяет начать диалог по идентификатору строки или продолжить текущий диалог (например, выполнить очередной шаг каскадного диалога).

По окончании диалога можно получить *результат диалога* с определенными сведениями. Этот результат возвращается вызывающему методу, чтобы он мог оценить события, выполненные в диалоге, и сохранить результаты в постоянное хранилище, если потребуется.

## <a name="dialog-state"></a>Состояние в Dialog

Объекты Dialog предназначены для реализации многоэтапного общения, а значит, их функциональность в пакете SDK зависит от возможности сохранения состояния на нескольких последовательных шагах. Без состояния диалога бот не сможет отслеживать, на каком шаге в наборе диалогов он находится и какую информацию он уже получил.

Бот на основе диалога обычно поддерживает коллекцию набора диалогов в качестве переменной-члена в реализации бота. Этот набор диалогов создается с дескриптором объекта, который называется методом доступа и предоставляет доступ к сохраненному состоянию. Общие сведения о состоянии для ботов см. в статье [об управлении состоянием](bot-builder-concept-state.md).

В обработчике шагов бот инициализирует подсистему диалога, вызывая из набора диалогов метод *create context*, который возвращает *контекст диалога*. Этот контекст диалога содержит все сведения, которые потребуются для работы диалога.

Для создания контекста диалогов потребуется состояние, которое извлекается с помощью метода доступа, который был предоставлен при создании набора диалогов. С помощью этого метода доступа набор диалогов получает сведения о состоянии диалога. Подробные сведения о методах доступа к состоянию см. в статье [Сохранение данных пользователя и диалога](bot-builder-howto-v4-state.md).

## <a name="dialog-types"></a>Типы диалогов

Есть несколько типов диалогов: запросы, каскадные диалоги и компонентные диалоги. Они представлены здесь в виде иерархии классов.

![Классы диалогов](media/bot-builder-dialog-classes.png)

### <a name="prompts"></a>Запросы

Запросы из библиотеки диалогов — это простой способ запросить у пользователя определенные сведения и оценить ответы. Например, для *запроса числа* вы определяете вопрос или подсказу о нужных сведениях, и запрос автоматически проверяет, является ли полученный ответ (число) допустимым. Если это так, диалог можно продолжить. В противном случае пользователю повторно предлагается ввести допустимый ответ.

Запросы данных, по сути, являются диалогами из двух этапов. Сначала запрос предлагает ввести данные, а затем возвращает допустимое значение или повторяет цикл запроса.

Запросы имеют *параметры запроса*, которые предоставляются при вызове запроса. Они позволяют указать текст для строки приглашения, строку повторного запроса при неудачной проверке и варианты ответа на запрос.

Кроме того, вы можете добавить в запрос пользовательские проверки при его создании. Предположим, что мы хотим узнать размер компании с помощью запроса числа, но этот размер будет ограничен значениями от 2 до 12. Такой запрос сначала проверяет, получил ли он допустимое число, а затем выполняет пользовательскую проверку, если она настроена. Если пользовательская проверка не будет пройдена успешно, запрос выведет повторное обращение к пользователю, как описано выше.

Завершенный запрос явным образом возвращает значение, которое было запрошено. Получив это значение, мы можем быть уверены, что оно удовлетворяет как встроенным параметрам проверки, так и любой настроенной пользовательской проверке.

Примеры разных запросов и их использования см. в руководстве по [сбору вводимых пользователем данных с помощью библиотеки диалогов](bot-builder-prompts.md).

#### <a name="prompt-types"></a>Типы запросов

Запросы данных, по сути, являются диалогами из двух этапов. На первом запрашиваются входные данные, а на втором возвращается допустимое значение или цикл запроса запускается заново. Библиотека диалогов содержит несколько простых запросов, каждый из которых возвращает разные типы ответов. Базовые запросы могут интерпретировать входные данные на естественном языке, например числа "ten" (десять) или "a dozen" (дюжина) и указания времени "tomorrow" (завтра) или "Friday at 10am" (в 10 вечера в пятницу).

| prompt | ОПИСАНИЕ | Результаты |
|:----|:----|:----|
| _Запрос вложений_ | Предложение передать одно или несколько вложений, например документов или изображений. | Коллекция объектов _вложений_. |
| _Запрос выбора_ | Предложение выбрать один параметр из набора. | Объект _найденного выбора_. |
| _Запрос подтверждения_ | Запрашивается подтверждение. | Логическое значение. |
| _Запрос даты и времени_ | Предложение ввести дату и (или) время. | Коллекция объектов _разрешения даты и времени_. |
| _Запрос числа_ | Предложение ввести число. | Числовое значение. |
| _Запрос текста_ | Предложение ввести входные данные в простом текстовом виде. | Строка. |

Чтобы запросить ввод данных от пользователя, определите запрос на основе одного из встроенных классов, например _текстового запроса_, и добавьте этот запрос в набор диалогов. Запросы имеют фиксированное идентификаторы, уникальные в пределах набора диалогов. Для каждого запроса вы можете создать пользовательский проверяющий элемент управления, а для некоторых — еще и указать _языковой стандарт по умолчанию_. 

#### <a name="prompt-locale"></a>Языковой стандарт для запроса

Языковой стандарт используется для определения поведения, зависящего от языка, в запросах **выбора**, **подтверждения**, **даты и времени** и **числа**. Для каждого полученного от пользователя сообщения действует следующее правило: если канал передает в сообщении _языковой стандарт_, то используется именно он. Если для запроса задан _языковой стандарт по умолчанию_ при вызове конструктора строки или позднее, то используется именно он. Если языковый стандарт не указан, в качестве языкового стандарта используется английский язык (en-us). Примечание. Языковой стандарт определяется кодом ISO 639 из 2, 3 или 4 символов, который указывает определенный язык или языковую группу.

### <a name="waterfall-dialogs"></a>Каскадные диалоги

Каскадным диалогом называют особую реализацию диалога, которая часто используется для сбора информации от пользователя или предоставления пользователю инструкций по выполнению ряда задач. Каждый шаг диалога реализуется как асинхронная функция, которая принимает параметр *контекста каскадного шага* (`step`). На каждом шаге бот [запрашивает у пользователя входные данные](bot-builder-prompts.md) (или запускает дочерний диалог — обычно это еще один запрос), ожидает ответа и передает результат в следующий шаг. Результат выполнения первой функции передается в виде аргумента следующую функцию и т. д.

На следующей диаграмме показана последовательность шагов каскада и выполняемых операций стека. Сведения об использовании стека диалогов см. ниже в разделе об [использовании диалогов](#using-dialogs).

![Концепция диалога](media/bot-builder-dialog-concept.png)

При выполнении шагов каскадного диалога сохраняется соответствующий *контекст*. Он применяется так же, как контекст диалога, то есть предоставляет сведения о контексте и состоянии текущего шага. Контекстный объект шага каскада используется для взаимодействия с набором диалогов из шага каскада.

Значение, возвращаемое диалогом, можно обрабатывать в другом каскадном шаге этого же диалога или в основном обработчике шагов бота. Обычно достаточно только проверить состояние результата шага диалога, полученное от логики обработчика шагов.
Внутри шага каскада диалог возвращает значение в контексте шага каскада в виде свойства _result_.

#### <a name="waterfall-step-context-properties"></a>Свойства контекста для каскадного шага

Контекст каскадного шага содержит следующие элементы:

* *Параметры* — входные данные для диалога.
* *Значения* — сведения, которые можно добавить в контекст и передать в последующие шаги.
* *Результат* — результат, полученный от предыдущего шага.

Кроме того, метод *next* позволяет перейти к следующему шагу каскадного диалога, не завершая текущий шаг. Это означает, что при необходимости бот может пропустить любой из шагов.

### <a name="component-dialog"></a>Диалог-компонент

Иногда вы будете создавать диалог для многократного использования, который применим для разных сценариев. В качестве примера можно представить диалог, который предлагает пользователю указать название улицы, город и почтовый индекс.

*Компонентный диалог* позволяет создавать независимые диалоги для обработки определенных сценариев, разбивая большие наборы диалогов на более управляемые компоненты. Каждый из этих компонентов имеет отдельный набор диалогов, что позволяет избежать конфликтов имен с родительским набором диалогов. Подробнее об этом см. в [руководстве по компонентным диалогам](bot-builder-compositcontrol.md).

## <a name="using-dialogs"></a>Использование диалогов

Контекст диалога помогает правильно начать, продолжить, заменить и завершить диалог. Вы также можете отменить все диалоги из текущего стека диалогов.

Диалоги можно рассматривать как структуру программного стека, который называется *стеком диалогов*. Управление стеком выполняет обработчик шагов диалога, и он же вызывается при пустом стеке. Самый верхний элемент в стеке считается *активным диалогом*, и именно в него контекст диалога направляет все вводимые пользователем данные.

Когда начинается новый диалог, он становится активным диалогом, перемещаясь на вершину стека. Он остается активным, пока не завершится, не будет удален с помощью метода [replace dialog](#repeating-a-dialog), или в стек не будет помещен новый диалог (из обработчика шагов или самим активным диалогом), который и станет новым активным диалогом. Когда новый активный диалог завершится, он будет извлечен из стека, и активным снова станет диалог, расположенный на предыдущем уровне стека. Это позволяет [повторять](#repeating-a-dialog) или [разветвлять](#branch-a-conversation) диалог, как описано ниже.


### <a name="create-the-dialog-context"></a>Создание контекста диалога

Чтобы создать контекст диалога, вызовите метод *create context* из набора диалогов. Метод create context получает свойство *состояния диалога* из набора диалогов и использует его для создания контекста диалога. Далее этот контекст диалога применяется для начала и продолжения диалогов из набора, а также управления этими диалогами.

Для использования состояния диалога набору диалогов требуется *метод доступа к свойству состояния*. Этот метод доступа создается и используется так же, как другие методы доступа к состоянию, но является свойством самого себя, основанным на состоянии диалога. См. дополнительные сведения об [управлении состоянием](bot-builder-concept-state.md), а также о [последовательном потоке диалога](bot-builder-dialog-manage-conversation-flow.md).

### <a name="to-start-a-dialog"></a>Начало диалога

Чтобы начать диалог, передайте нужный идентификатор *dialogId* в метод *begin dialog*, *prompt* или *replace dialog* контекста диалога.

* С помощью метода begin dialog диалог отправляется на вершину стека.
* С помощью метода replace dialog текущий диалог извлекается из стека и в стек помещается новый диалог. Замененный диалог будет отменен, а все сведения, содержащиеся в этом экземпляре, удалены.

Используйте параметр _options_ для передачи сведений в новый экземпляр диалога.
Параметры, передаваемые в новый диалог, можно получить из контекста шага с помощью свойства *options* на любом шаге диалога.
См. дополнительные сведения о [создании сложного потока беседы с использованием ветвления и циклов с примером кода](bot-builder-dialog-manage-complex-conversation-flow.md).

### <a name="to-continue-a-dialog"></a>Продолжение диалога

Чтобы продолжить диалог, вызовите метод *continue dialog*. Метод continue всегда продолжает верхний (активный) диалог в стеке, если таковой имеется. Когда продолжаемый диалог завершится, управление передастся в контекст родительского элемента, и он будет продолжен на том же шаге.

Используйте свойство *values* контекста шага, чтобы сохранить состояния между шагами.
Любое значение, добавляемое в эту коллекцию на предыдущем шаге, будет доступно на следующих шагах.
См. дополнительные сведения о [создании сложного потока беседы с использованием ветвления и циклов с примером кода](bot-builder-dialog-manage-complex-conversation-flow.md).

### <a name="to-end-a-dialog"></a>Завершение диалога

Метод *end dialog* завершает диалог, извлекая его из стека и возвращает результат (необязательный) в родительский диалог (например, в вызвавший его диалог или обработчик шагов бота). Чаще всего этот метод вызывается из диалога для того, чтобы завершить текущий экземпляр этого диалога.

Вы можете вызвать метод end из любого места в контексте диалогов, но для бота этот вызов всегда будет выглядеть как поступивший из текущего активного диалога.

> [!TIP]
> Мы рекомендуем явным образом вызывать метод *end dialog*  в конце диалога.

### <a name="to-clear-all-dialogs"></a>Очистка всех диалогов

Если нужно извлечь все диалоги из стека, можно очистись стек диалога, вызвав метод *cancel all dialogs* для контекста диалога.

### <a name="repeating-a-dialog"></a>Повторение диалога

Диалог можно заменить им же, создав цикл с помощью метода *replace dialog*.
Это отличный способ организовать [сложную итерацию](~/v4sdk/bot-builder-dialog-manage-complex-conversation-flow.md) или управление меню.

> [!NOTE]
> Если вам нужно сохранить внутреннее состояние текущего диалога, передайте сведения новому экземпляру диалога в вызове метода *replace dialog*, а затем соответствующим образом инициализируйте этот диалог.

### <a name="branch-a-conversation"></a>Ветвление диалога

Контекст диалога поддерживает стек диалогов и помнит следующий шаг для каждого диалога в стеке. Его метод *begin dialog* создает дочерний диалог и помещает его на вершину стека, а метод *end dialog* извлекает из стека верхний диалог. *End dialog* обычно вызывается из диалога, работу которого нужно завершить.

Диалог может начать новый диалог внутри того же набора диалогов, вызвав метод *begin dialog* контекста диалога и указав идентификатор нового диалога. При этом новый диалог становится текущим активным диалогом. Исходный диалог по-прежнему находится в стеке, но вызовы метода *continue dialog* для контекста диалога отправляются только тому диалогу, который находится на вершине стека, т. е. *активному диалогу*. Когда диалог извлекается из стека, контекст диалога продолжает выполнение со следующего шага в каскадной последовательности, хранящейся в стеке, на котором остановился исходный диалог.

Таким образом, можно создать ветвь в процессе общения, добавив шаг в один диалог, который на основе условия может выбрать другой диалог из набора доступных диалогов и начать его.

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Использование библиотеки диалогов для сбора данных, вводимых пользователем](bot-builder-prompts.md)
