---
title: Диалоги в пакете SDK Bot Builder | Документация Майкрософт
description: Сведения о диалоге и его использовании в пакете SDK Bot Builder.
keywords: conversation flow, recognize intent, single turn, multiple turn, bot conversation, dialogs, prompts, waterfalls, dialog set
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 9/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 88022c387d5f9ef7f645be74010aba3c676efadc
ms.sourcegitcommit: cb0b70d7cf1081b08eaf1fddb69f7db3b95b1b09
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "51332938"
---
# <a name="dialogs-library"></a>Библиотека диалогов

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

В основе этого пакета SDK лежит управление беседами путем использования понятия Dialog. Объекты Dialog обрабатывают входящие действия и генерируют исходящие ответы. Бизнес-логика бота прямо или косвенно выполняется в классах Dialog.

Во время выполнения экземпляры класса Dialog размещаются в стеке. Объект Dialog на вершине стека обозначается как ActiveDialog. Текущий активный диалог обрабатывает входящие действия. Состояние стека сохраняется между репликами общения (которое не ограничено во времени и может длиться несколько дней и дольше). 

## <a name="dialog-lifecycle"></a>Жизненный цикл диалога

Класс Dialog реализует три основные функции:
- BeginDialog;
- ContinueDialog;
- ResumeDialog.

Во время выполнения классы Dialog и DialogContext взаимодействуют друг с другом, чтобы выбрать для обработки действия соответствующий объект Dialog. Класс DialogContext связывает сохраняемый стек объектов Dialog, входящее действие и класс DialogSet. Класс DialogSet содержит диалоги, которые может вызвать бот.

Интерфейс класса DialogContext отражает базовый принцип начала и продолжения диалога. Общая схема работы приложения заключается в том, что сначала всегда вызывается метод ContinueDialog. Если нет стека, а значит объекта ActiveDialog, приложение должно начать работу с выбранным объектом Dialog, вызвав метод BeginDialog объекта DialogContext. В результате соответствующей объект Dialog из набора DialogSet помещается в стек (с технической точки зрения в стек помещается идентификатор объекта Dialog), и стек делегирует вызов метода BeginDialog этого объекта Dialog. Если объект ActiveDialog существует, стек просто делегирует вызов метода ContinueDialog этого объекта Dialog, присваивая ему при этом соответствующие постоянные свойства.

Обратите внимание, что метод **BeginDialog объекта Dialog** содержит код инициализации и принимает соответствующие свойства (в коде они называются options), а **метод ContinueDialog объекта Dialog** содержит код, который запускается для продолжения выполнения при поступлении действия после сохранения. Если, к примеру, объект Dialog используется, чтобы задать пользователю вопрос, тогда вопрос задается в методе BeginDialog, а ответ ожидается в методе ContinueDialog.

Для поддержки вложенных объектов Dialog (когда диалог содержит дочерний диалог) существует дополнительный тип продолжения, называемый возобновлением. Завершив дочерний объект Dialog, DialogContext вызовет метод ResumeDialog родительского объекта Dialog.

Запросы и каскады — это конкретные примеры объектов Dialog, предоставляемые пакетом SDK. Множество сценариев создаются путем объединения этих абстракций, но внутренняя логика всегда следует описанному здесь шаблону — начало, продолжение и возобновление. Реализация класса Dialog "с нуля" — относительно сложная задача (см. [примеры](https://github.com/Microsoft/BotBuilder-samples)).

Библиотека объектов **Dialog** пакета SDK Bot Builder включает встроенные функции, например _запросы_, _каскадные диалоги_ и _диалоги-компоненты_, которые помогают управлять общением с ботом. Запросы можно использовать, чтобы запрашивать у пользователей различные сведения, каскад позволяет объединять несколько шагов в последовательность, а диалоги-компоненты упаковывают логику диалога в отдельные классы, которые затем можно интегрировать в другие боты.
## <a name="waterfall-dialogs-and-prompts"></a>Каскады и запросы

Библиотека классов **Dialog** содержит набор различных типов запросов, которые можно использовать, чтобы запрашивать у пользователей те или иные сведения. Например, чтобы пользователь ввел текст, можно использовать **TextPrompt**, для ввода числа можно использовать **NumberPrompt**, а для ввода даты и времени можно использовать **DateTimePrompt**. Запросы — это отдельные типы диалогов. Чтобы использовать запрос в каскаде, добавьте каскад и запрос в тот же набор диалогов. 

Из-за самой природы взаимодействия "запрос-ответ" при реализации запроса необходимо, чтобы каскадный диалог включал не менее двух шагов — один для отправки запроса и второй для получения и обработки ответа.  Если есть дополнительный запрос, иногда его можно объединить с текущим запросом путем использования одной функции, которая сначала обрабатывает ответ пользователя, а затем начинает следующий запрос.

`WaterfallDialog` — это конкретная реализация диалога, который используется для получения сведений от пользователя или предоставления пользователю инструкций по выполнению ряда задач. Задачи реализуются как массив функций, в котором результат выполнения первой функции передается в качестве аргумента в следующую функцию и т. д. Каждая функция обычно представляет один шаг в общем процессе. На каждом шаге бот запрашивает у пользователя входные данные, ожидает ответа, а затем передает результат на следующий шаг. 

Запросы и каскады являются подтипами диалогов, как показано на схеме иерархии классов ниже. 

![Классы диалогов](media/bot-builder-dialog-classes.png)

Каскадный диалог состоит из последовательности шагов каскада. Каждый шаг представляет собой асинхронный делегат, который принимает в качестве параметра _контекст шага каскада_ (`step`). В используемом шаблоне последней операцией в шаге каскада является запуск дочернего диалога (обычно запроса) или завершение самого каскада. На следующей диаграмме показана последовательность шагов каскада и выполняемых операций стека.

![Концепция диалога](media/bot-builder-dialog-concept.png)

Возвращаемое диалогом значение может обрабатываться внутри шага каскада или в поочередном обработчике бота.
Внутри шага каскада диалог возвращает значение в контексте шага каскада в виде свойства _result_.
Обычно в поочередной логике бота требуется только проверить состояние результата шага диалога.

## <a name="repeating-a-dialog"></a>Повторение диалога

Чтобы повторить диалог, используйте метод *replace dialog*. Метод контекста диалога *replace dialog* извлечет текущий диалог из стека, поместит новый диалог на вершину стека и начнет его выполнение. Этот метод можно использовать для создания цикла, в котором диалог будет заменяться собой. Обратите внимание: если вам нужно сохранить внутреннее состояние текущего диалога, необходимо передать сведения новому экземпляру диалога в вызове метода _replace dialog_, а затем инициализировать диалог соответствующим образом. Параметры, передаваемые в новый диалог, можно получить из контекста шага с помощью свойства _options_ на любом шаге диалога. Это хороший способ реализации сложной последовательности общения или управления меню.

## <a name="branch-a-conversation"></a>Ветвление диалога

В контексте диалога содержится _стек диалогов_, и для каждого диалога из стека отслеживается, какой шаг будет следующим. Чтобы поместить диалог на вершину стека, используется метод _begin dialog_, а для извлечения диалога с вершины стека используется метод _end dialog_.

Диалог может начать новый диалог внутри того же набора диалогов, вызвав метод _begin dialog_ контекста диалога и указав идентификатор нового диалога. При этом новый диалог становится текущим активным диалогом. Исходный диалог по-прежнему находится в стеке, но вызовы метода _continue dialog_ для контекста диалога отправляются только тому диалогу, который находится на вершине стека, т. е. _активному диалогу_. Когда диалог извлекается из стека, контекст диалога продолжает выполнение со следующего шага в каскадной последовательности, хранящейся в стеке, на котором остановился исходный диалог.

Таким образом, можно создать ветвь в процессе общения, добавив шаг в один диалог, который на основе условия может выбрать другой диалог из набора доступных диалогов и начать его.

## <a name="component-dialog"></a>Диалог-компонент
Иногда необходимо создать класс Dialog, который можно повторно использовать в различных сценариях. Примером может служить класс Dialog для запроса адреса, который запрашивает у пользователя адрес, город и почтовый индекс. 

Класс ComponentDialog обеспечивает уровень изоляции, поскольку он имеет отдельный набор DialogSet. Наличие отдельного набора DialogSet позволяет избежать конфликта имен с родительским классом Dialog. Этот класс создает собственную независимую среду выполнения класса Dialog (путем создания собственного экземпляра DialogContext) и передает в нее действия. Такое вложенное выполнение дает возможность перехватывать действия. Это может оказаться полезным при реализации таких команд, как help или cancel.  См. пример Enterprise Bot Template. 

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Использование библиотеки диалогов для сбора данных, вводимых пользователем](bot-builder-prompts.md)
