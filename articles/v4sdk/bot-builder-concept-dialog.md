---
title: Диалоги в пакете SDK Bot Builder | Документация Майкрософт
description: Сведения о диалоге и его использовании в пакете SDK Bot Builder.
keywords: conversation flow, prompt, dialog state, recognize intent, single turn, multiple turn, bot conversation, dialogs, prompts, waterfalls, dialog set
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/22/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 964d4a0344df595630f5b38fa32b3cc3a526ed5c
ms.sourcegitcommit: bbfb171f515c50a3c8bba5ca898daf25cf764378
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2018
ms.locfileid: "52293596"
---
# <a name="dialogs-library"></a>Библиотека диалогов

[!INCLUDE [pre-release-label](../includes/pre-release-label.md)]

В основе этого пакета SDK лежит управление беседами путем использования понятия Dialog. Объекты Dialog обрабатывают входящие действия и генерируют исходящие ответы. Бизнес-логика бота прямо или косвенно выполняется в классах Dialog.

Во время выполнения экземпляры класса Dialog размещаются в стеке. Объект Dialog на вершине стека обозначается как ActiveDialog. Текущий активный диалог обрабатывает входящие действия. Состояние стека сохраняется между репликами общения (которое не ограничено во времени и может длиться несколько дней и дольше). 

## <a name="dialog-lifecycle"></a>Жизненный цикл диалога

Класс Dialog реализует три основные функции:
- BeginDialog;
- ContinueDialog;
- ResumeDialog.

Во время выполнения классы Dialog и DialogContext взаимодействуют друг с другом, чтобы выбрать для обработки действия соответствующий объект Dialog. Класс DialogContext связывает сохраняемый стек объектов Dialog, входящее действие и класс DialogSet. Класс DialogSet содержит диалоги, которые может вызвать бот.

Интерфейс класса DialogContext отражает базовый принцип начала и продолжения диалога. Общая схема работы приложения заключается в том, что сначала всегда вызывается метод ContinueDialog. Если нет стека, а значит объекта ActiveDialog, приложение должно начать работу с выбранным объектом Dialog, вызвав метод BeginDialog объекта DialogContext. В результате соответствующей объект Dialog из набора DialogSet помещается в стек (с технической точки зрения в стек помещается идентификатор объекта Dialog), и стек делегирует вызов метода BeginDialog этого объекта Dialog. Если объект ActiveDialog существует, стек просто делегирует вызов метода ContinueDialog этого объекта Dialog, присваивая ему при этом соответствующие постоянные свойства.

Обратите внимание, что метод **BeginDialog объекта Dialog** содержит код инициализации и принимает соответствующие свойства (в коде они называются options), а **метод ContinueDialog объекта Dialog** содержит код, который запускается для продолжения выполнения при поступлении действия после сохранения. Если, к примеру, объект Dialog используется, чтобы задать пользователю вопрос, тогда вопрос задается в методе BeginDialog, а ответ ожидается в методе ContinueDialog.

Для поддержки вложенных объектов Dialog (когда диалог содержит дочерний диалог) существует дополнительный тип продолжения, называемый возобновлением. Завершив дочерний объект Dialog, DialogContext вызовет метод ResumeDialog родительского объекта Dialog.

Запросы и каскады — это конкретные примеры объектов Dialog, предоставляемые пакетом SDK. Множество сценариев создаются путем объединения этих абстракций, но внутренняя логика всегда следует описанному здесь шаблону — начало, продолжение и возобновление. 

Библиотека объектов **Dialog** пакета SDK Bot Builder включает встроенные функции, например _запросы_, _каскадные диалоги_ и _диалоги-компоненты_, которые помогают управлять общением с ботом. Запросы можно использовать, чтобы запрашивать у пользователей различные сведения, каскад позволяет объединять несколько шагов в последовательность, а диалоги-компоненты упаковывают логику диалога в отдельные классы, которые затем можно интегрировать в другие боты.
## <a name="waterfall-dialogs-and-prompts"></a>Каскады и запросы

Библиотека классов **Dialog** содержит набор различных типов запросов, которые можно использовать, чтобы запрашивать у пользователей те или иные сведения. Например, чтобы пользователь ввел текст, можно использовать **TextPrompt**, для ввода числа можно использовать **NumberPrompt**, а для ввода даты и времени можно использовать **DateTimePrompt**. Запросы — это отдельные типы диалогов. Чтобы использовать запрос в каскаде, добавьте каскад и запрос в тот же набор диалогов. 

Из-за самой природы взаимодействия "запрос-ответ" при реализации запроса необходимо, чтобы каскадный диалог включал не менее двух шагов — один для отправки запроса и второй для получения и обработки ответа.  Если есть дополнительный запрос, иногда его можно объединить с текущим запросом путем использования одной функции, которая сначала обрабатывает ответ пользователя, а затем начинает следующий запрос.

`WaterfallDialog` — это конкретная реализация диалога, который используется для получения сведений от пользователя или предоставления пользователю инструкций по выполнению ряда задач. Задачи реализуются как массив функций, в котором результат выполнения первой функции передается в качестве аргумента в следующую функцию и т. д. Каждая функция обычно представляет один шаг в общем процессе. На каждом шаге бот запрашивает у пользователя входные данные, ожидает ответа, а затем передает результат на следующий шаг. 

Запросы и каскады являются подтипами диалогов, как показано на схеме иерархии классов ниже. 

![Классы диалогов](media/bot-builder-dialog-classes.png)

Каскадный диалог состоит из последовательности шагов каскада. Каждый шаг представляет собой асинхронный делегат, который принимает в качестве параметра _контекст шага каскада_ (`step`). В используемом шаблоне последней операцией в шаге каскада является запуск дочернего диалога (обычно запроса) или завершение самого каскада. На следующей диаграмме показана последовательность шагов каскада и выполняемых операций стека.

![Концепция диалога](media/bot-builder-dialog-concept.png)

Возвращаемое диалогом значение может обрабатываться внутри шага каскада или в поочередном обработчике бота.
Внутри шага каскада диалог возвращает значение в контексте шага каскада в виде свойства _result_.
Обычно в поочередной логике бота требуется только проверить состояние результата шага диалога.

## <a name="about-prompt-types"></a>Сведения о типах запросов

Запросы данных, по сути, являются диалогами из двух этапов. На первом запрашиваются входные данные, а на втором возвращается допустимое значение или цикл запроса запускается заново. Библиотека диалогов содержит несколько простых запросов, каждый из которых возвращает разные типы ответов. Базовые запросы могут интерпретировать входные данные на естественном языке, например числа "ten" (десять) или "a dozen" (дюжина) и указания времени "tomorrow" (завтра) или "Friday at 10am" (в 10 вечера в пятницу).

| prompt | ОПИСАНИЕ | Результаты |
|:----|:----|:----|
| _Запрос вложений_ | Предложение передать одно или несколько вложений, например документов или изображений. | Коллекция объектов _вложений_. |
| _Запрос выбора_ | Предложение выбрать один параметр из набора. | Объект _найденного выбора_. |
| _Запрос подтверждения_ | Запрашивается подтверждение. | Логическое значение. |
| _Запрос даты и времени_ | Предложение ввести дату и (или) время. | Коллекция объектов _разрешения даты и времени_. |
| _Запрос числа_ | Предложение ввести число. | Числовое значение. |
| _Запрос текста_ | Предложение ввести входные данные в простом текстовом виде. | Строка. |

Чтобы запросить ввод данных от пользователя, определите запрос на основе одного из встроенных классов, например _текстового запроса_, и добавьте этот запрос в набор диалогов. Запросы имеют фиксированное идентификаторы, уникальные в пределах набора диалогов. Для каждого запроса вы можете создать пользовательский проверяющий элемент управления, а для некоторых — еще и указать _языковой стандарт по умолчанию_. 

### <a name="prompt-locale"></a>Языковой стандарт для запроса

Языковой стандарт используется для определения поведения, зависящего от языка, в запросах **выбора**, **подтверждения**, **даты и времени** и **числа**. Для каждого полученного от пользователя сообщения действует следующее правило: если канал передает в сообщении _языковой стандарт_, то используется именно он. Если для запроса задан _языковой стандарт по умолчанию_ при вызове конструктора строки или позднее, то используется именно он. Если языковый стандарт не указан, в качестве языкового стандарта используется английский язык (en-us). Примечание. Языковой стандарт определяется кодом ISO 639 из 2, 3 или 4 символов, который указывает определенный язык или языковую группу.

## <a name="dialog-state"></a>Состояние в Dialog

Объекты Dialog предназначены для реализации многоэтапного общения, а значит, их функциональность в пакете SDK зависит от возможности сохранения состояния на нескольких последовательных шагах. Без состояния диалога бот не сможет отслеживать, на каком этапе в наборе диалогов он находится и какую информацию уже получил.

Бот на основе диалога обычно поддерживает коллекцию набора диалогов в качестве переменной-члена в реализации бота. Этот набор диалогов создается с дескриптором объекта, который называется методом доступа и предоставляет доступ к сохраненному состоянию. Общие сведения о состоянии для ботов см. в статье [об управлении состоянием](bot-builder-concept-state.md). 

![Состояние в Dialog](media/bot-builder-dialog-state.png)

При вызове обработчика шагов бота он инициализирует подсистему диалога, вызывая метод *create context* для набора диалогов, который возвращает *контекст диалога*. Для создания контекста диалогов потребуется состояние, которое извлекается с помощью метода доступа, который был предоставлен при создании набора диалогов. С помощью этого метода доступа диалог получает JSON-объект соответствующего состояния диалога. Этот контекст диалога содержит все сведения, которые потребуются для работы диалога.

Подробные сведения о методах доступа к состоянию см. в статье [Сохранение данных пользователя и диалога](bot-builder-howto-v4-state.md).

## <a name="repeating-a-dialog"></a>Повторение диалога

Чтобы повторить диалог, используйте метод *replace dialog*. Метод контекста диалога *replace dialog* извлечет текущий диалог из стека, поместит новый диалог на вершину стека и начнет его выполнение. Этот метод можно использовать для создания цикла, в котором диалог будет заменяться собой. Обратите внимание: если вам нужно сохранить внутреннее состояние текущего диалога, необходимо передать сведения новому экземпляру диалога в вызове метода _replace dialog_, а затем инициализировать диалог соответствующим образом. Параметры, передаваемые в новый диалог, можно получить из контекста шага с помощью свойства _options_ на любом шаге диалога. Это хороший способ реализации сложной последовательности общения или управления меню.

## <a name="branch-a-conversation"></a>Ветвление диалога

В контексте диалога содержится _стек диалогов_, и для каждого диалога из стека отслеживается, какой шаг будет следующим. Чтобы поместить диалог на вершину стека, используется метод _begin dialog_, а для извлечения диалога с вершины стека используется метод _end dialog_.

Диалог может начать новый диалог внутри того же набора диалогов, вызвав метод _begin dialog_ контекста диалога и указав идентификатор нового диалога. При этом новый диалог становится текущим активным диалогом. Исходный диалог по-прежнему находится в стеке, но вызовы метода _continue dialog_ для контекста диалога отправляются только тому диалогу, который находится на вершине стека, т. е. _активному диалогу_. Когда диалог извлекается из стека, контекст диалога продолжает выполнение со следующего шага в каскадной последовательности, хранящейся в стеке, на котором остановился исходный диалог.

Таким образом, можно создать ветвь в процессе общения, добавив шаг в один диалог, который на основе условия может выбрать другой диалог из набора доступных диалогов и начать его.

## <a name="component-dialog"></a>Диалог-компонент
Иногда необходимо создать класс Dialog, который можно повторно использовать в различных сценариях. Примером может служить класс Dialog для запроса адреса, который запрашивает у пользователя адрес, город и почтовый индекс. 

Класс ComponentDialog обеспечивает уровень изоляции, поскольку он имеет отдельный набор DialogSet. Наличие отдельного набора DialogSet позволяет избежать конфликта имен с родительским классом Dialog. Этот класс создает собственную независимую среду выполнения класса Dialog (путем создания собственного экземпляра DialogContext) и передает в нее действия. Такое вложенное выполнение дает возможность перехватывать действия. Это может оказаться полезным при реализации таких команд, как help или cancel.  См. пример [Шаблон Enterprise Bot](https://aka.ms/abs/templates/cabot). 

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Использование библиотеки диалогов для сбора данных, вводимых пользователем](bot-builder-prompts.md)
