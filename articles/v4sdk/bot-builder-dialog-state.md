---
title: Состояние в Dialog | Документация Майкрософт
description: Описание использования сведений о состоянии при использовании пакета SDK для Bot Builder.
keywords: state, bot state, conversation state, user state
author: johnataylor
ms.author: johtaylo
manager: kamrani
ms.topic: article
ms.prod: bot-framework
ms.date: 9/21/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 0fb42643b195f55c8fae73f41b622377f8da2a5c
ms.sourcegitcommit: d4afc924b0e1907c4d6f7a6fc5ac1fe521aeef7e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/28/2018
ms.locfileid: "47447329"
---
# <a name="dialog-state"></a>Состояние в Dialog

Объекты Dialog предназначены для реализации логики многоэтапного общения, а значит, их функциональность в пакете SDK зависит от возможности сохранения состояния на всех этапах работы. 

Бот на основе Dialog обычно поддерживает коллекцию DialogSet в качестве переменной-члена в реализации бота. DialogSet создается с дескриптором, который указывает на объект Accessor. 

Это реализация метода доступа, который является ключевой концепцией в модели состояния для пакета SDK. Метод доступа реализует интерфейс IStatePropertyAccessor, а значит он должен предоставлять реализации для методов Get (получение), Set (установка) и Delete (удаление). Чтобы создать объект Accessor, нужно указать для него имя свойства. 

Код, который использует Accessor, может вызывать его методы Get, Set и (или) Delete с учетом того, что эти вызовы будут обращаться к свойству с соответствующим именем. Если компоненту более высокого уровня требуется сохранение состояния, следует использовать Accessor. Это позволит создавать для каждого сценария собственную реализацию хранилища состояний, сохраняя неизменным код высокого уровня. Например, Dialog использует Accessor как единственный способ доступа к сохраненному состоянию.

![Состояние в Dialog](media/bot-builder-dialog-state.png)

При вызове метода OnTurn чат-бота инициализируется подсистема Dialog путем вызова CreateContext для DialogSet. Для создания DialogContext нужно знать состояние, поэтому DialogSet использует объект Accessor для получения (Get) состояния соответствующего диалога в формате JSON. Пакет SDK предоставляет реализацию Accessor в классе BotState. Приложения, которые намерены использовать реализацию состояния, могут создать подкласс и наследовать от BotState реализацию метода доступа в объекте Accessor. В пакет SDK включены два подкласса BotState:

- UserState
- ConversationState

UserState и ConversationState используют ключи для базового хранилища. Ключ передается в физическое хранилище Логически ключ действует как пространство имен для свойства, имя которому присваивает Accessor. Реализация BotState на внутреннем уровне использует действие, заданное входящим параметром Activity, для TurnContext, чтобы динамически создать используемый ключ хранилища.

- UserState создает ключ на основе идентификатора канала (Channel Id) и идентификатора источника (From Id). Например, _{Activity.ChannelId}/conversations/{Activity.From.Id}#DialogState_
- ConversationState создает ключ на основе идентификатора канала (Channel Id) и идентификатора общения (Conversation Id). Например, _{Activity.ChannelId}/users/{Activity.Conversation.Id}#YourPropertyName_

Приложению нужно предоставить объект Accessor, привязку к допустимому динамически созданному ключу хранения и имя свойства. Все это выполняется незаметно для пользователя. Реализация Accessor в BotState включает в себя некоторые оптимизации. 

- Первая из них — отложенная загрузка с кэшированием. Обращение к фактической реализации хранилища откладывается до первого вызова метода Get из объекта Accessor, а результат этого обращения сохраняется в кэше. Ссылка на этот кэш добавляется в TurnContext с указанием ключа, предоставленного в соответствующем BotState. Таким образом, кэш для состояния UserState будет сохраняться в поле с именем UserState, а кэш для ConversationState — в поле с именем ConversationState. Вызовы к разным объектам Accessor получают значение TurnContext, которое позволяет получить данные из соответствующего кэша.

- Вторая оптимизация заключается в том, что класс BotState содержит логику для отслеживания изменений состояния. Фактическая операция сохранения в базовое хранилище выполняется только в том случае, если были внесены изменения.

- Третья оптимизация в реализации BotState — это специальный класс с именем BotStateSet. BotStateSet содержит коллекцию объектов BotState, которая делегирует вызов метода SaveChanges параллельно каждому своему члену.

Важно понимать, что вызов метода SaveChanges для BotState не является частью интерфейса IStatePropertyAccessor. Это объясняется тем, что SaveChanges является оптимизацией в конкретной реализации BotState, а не базовым аспектом модели. В частности, код объекта Dialog ничего не знает даже о BotState, не говоря уже о SaveChanges. Весь код Dialog по сути связан только с объектом Accessor. Цель этой оптимизации в том, что метод SaveChanges должен вызываться вне системы Dialog и только после завершения ее выполнения. На схеме представлен пример, где такой вызов выполняется из метода OnTurn чат-бота.

Здесь важно отметить, что реализация BotState добавляет некоторую собственную семантику. В частности, в ней используется подход "приоритет имеет последняя запись", то есть последняя операция записи отменяет все ранее сохраненные состояния. Это будет корректно работать для многих приложений, но имеет свои побочные эффекты, особенно в сценариях горизонтального масштабирования с определенным уровнем параллелизма. Если это критично, создайте собственную реализацию Accessor и передавайте ее в Dialog. Существует множество альтернативных подходов. Например, в решении можно использовать популярное в облачных службах хранения, в том числе в Службе хранилища Azure, условие eTag. В этом случае решение будет содержать реализацию и других важных частей. Например, можно поддерживать буфер исходящих действий, отправляя очередное только после успешного завершения операции сохранения. Важно отметить, что такое поведение не относится к реализации BotState, а должно быть создано и подключено где-то на уровне Accessor.

Сама реализация BotState использует модель подключаемого хранилища. В ней используется простой шаблон загрузки и сохранения, а пакет SDK предоставляет две альтернативные реализации для рабочей среды. Одна из них предназначена для Службы хранилища Azure, а вторая — для CosmosDB. Есть также реализация в памяти для задач тестирования. Здесь важно отметить, то, что семантика "приоритет имеет последняя запись" навязывается реализацией BotState.

## <a name="handling-state-in-middleware"></a>Обработка состояний в ПО промежуточного слоя
На приведенной выше схеме показан вызов SaveAllChanges, который происходит в конце метода OnTurn чат-бота. Вы снова видите ту же схему, но теперь здесь выделен вызов функции.

![Проблемы состояния для ПО промежуточного слоя](media/bot-builder-dialog-state-problem.png)

Проблемой такого подхода является то, что любые обновления состояния из некоторых пользовательских реализаций ПО промежуточного слоя, полученные после завершения метода OnTurn чат-бота, не будут сохранены в долговременное хранилище. В качестве решения можно перенести этот вызов в SaveAllChanges сразу после завершения работы пользовательского ПО промежуточного слоя, добавив AutoSaveChangesMiddleware в конец стека ПО промежуточного слоя. Такая реализация представлена в следующем примере.

![Решение проблемы состояния для ПО промежуточного слоя](media/bot-builder-dialog-state-solution.png)

## <a name="additional-resources"></a>Дополнительные ресурсы
Дополнительные сведения см. в описании пакета SDK для Bot Builder на GitHub [[C#](https://github.com/Microsoft/BotBuilder-dotnet) | [JavaScript](https://github.com/Microsoft/BotBuilder-js)].
