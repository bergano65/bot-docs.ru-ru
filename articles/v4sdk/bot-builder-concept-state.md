---
title: Управление состоянием | Документация Майкрософт
description: Описание использования сведений о состоянии при использовании пакета SDK для Bot Builder.
keywords: state, bot state, conversation state, user state
author: ivorb
ms.author: v-ivorb
manager: kamrani
ms.topic: article
ms.service: bot-service
ms.subservice: sdk
ms.date: 11/15/2018
monikerRange: azure-bot-service-4.0
ms.openlocfilehash: 366a985e839c8a79fcd8794c139e2e8130a05335
ms.sourcegitcommit: 6cb37f43947273a58b2b7624579852b72b0e13ea
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2018
ms.locfileid: "52288880"
---
# <a name="managing-state"></a>Управление состоянием

Состояние бота подчиняется тем же принципам, что и современные веб-приложения, и пакет SDK для Bot Framework предоставляет некоторые абстракции, позволяющие упростить управление состоянием.

Как и веб-приложения, бот по своей природе не учитывает состояния. Любой экземпляр бота может обработать любой шаг беседы. Для некоторых ботов такая простота идеальна — либо они могут работать без дополнительных сведений, либо все нужные сведения гарантированно присутствуют во входящем сообщении. Другим ботам сведения о состоянии (например, текущее положение в цепочке беседы или уже полученные данные о пользователе) необходимы, чтобы поддерживать полезную беседу.

**Зачем мне нужно состояние?**

Поддержание состояния позволяет боту повысить информативность бесед путем запоминания некоторых данных о пользователе и (или) диалогах. Например, если вы уже общались ранее с некоторым пользователем, вы можете сохранить информацию о нем и не запрашивать ее повторно. Кроме того, состояние сохраняет данные не только о последнем шаге, что позволяет боту хранить сведения о ходе многоэтапного диалога.

В отношении ботов использование состояния затрагивает несколько уровней, которые мы рассмотрим в этой статье: уровень хранения, управление состоянием и методы доступа к свойству состояния.

## <a name="storage-layer"></a>Уровень хранения

Серверная часть, где фактически хранятся сведения о состоянии, называется *уровнем хранения*. Его можно считать физическим хранилищем, например, в этой роли могут выступать база данных в памяти, платформа Azure или сервер стороннего поставщика услуг.

Пакет SDK Bot Framework содержит разные реализации уровня хранилища, например хранилища в памяти для локального тестирования, службы хранилища Azure или CosmosDB для тестирования и развертывания в облаке.

## <a name="state-management"></a>Управление данными о состоянии

*Управление состоянием* автоматизирует получение и сохранение состояния бота на уровне хранилища. Состояние хранится в виде *свойств состояния*, то есть пар "ключ — значение", которые бот может считывать и записывать через объект управления состоянием, не беспокоясь о конкретной реализации. Свойства состояния определяют, как хранятся эти данные. Например, извлекая свойство со значением определенного класса или объекта, вы заранее знаете структуру этих данных.

Эти свойства состояния размещаются в "контейнерах" с определенной областью видимости, которые представляют собой коллекции для упорядочивания этих свойств. Пакет SDK поддерживает три таких "контейнера":

- состояние пользователя;
- состояние беседы;
- личное состояние беседы.

Все эти контейнеры являются подклассами класса *bot state* (состояние бота), на основе которого вы можете определить и другие типы контейнеров.

Эти предустановленные контейнеры имеют определенные области видимости.

- Состояние пользователя доступно на любом шаге, который бот выполняет в любой беседе с определенным пользователем на определенном канале.
- Состояние беседы доступно на любом шаге конкретной беседы для любого пользователя (например, в групповой беседе).
- Для личного состояния беседы область ограничивается как конкретным диалогом, так и конкретным пользователем.

В каждом из стандартных контейнеров используются ключи, определенные для пользователя, для беседы или для обоих этих объектов. При настройке значения для свойства состояния определяется внутренний ключ с информацией в контексте шага, которая позволяет правильно соотносить пользователей и беседы с контейнерами и свойствами. Определяются следующие ключи:

- Состояние пользователя создает ключ на основе идентификатора канала (*Channel Id*) и идентификатора источника (*From Id*). Например: _{Activity.ChannelId}/users/{Activity.From.Id}#ИмяСвойства_.
- Состояние беседы создает ключ на основе идентификатора канала (*Channel Id*) и идентификатора общения (*Conversation Id*). Например: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}#ИмяСвойства_.
- Личное состояние беседы создает ключ на основе идентификатора канала (*Channel Id*), идентификатора источника (*From Id*) и идентификатора общения (*Conversation Id*). Например: _{Activity.ChannelId}/conversations/{Activity.Conversation.Id}/users/{Activity.From.Id}#ИмяСвойства_

Дополнительные сведения о предопределенных контейнерах см. в [практическом руководстве по работе с состоянием](bot-builder-howto-v4-state.md).

## <a name="state-property-accessors"></a>Методы доступа к свойству состояния

*Методы доступа к свойству состояния* позволяют считывать и сохранять из текущего шага свойства состояния через предоставляемые методы *get*, *set* и *delete*. Чтобы создать метод доступа, укажите имя свойства. Обычно это происходит при инициализации бота. Позже вы сможете использовать этот метод доступа для получения и (или) изменения свойства в состоянии бота.

Методы доступа позволяют пакету SDK получать состояние из базового хранилища и самостоятельно обновляют *кэш состояний* бота. Кэш состояний представляет собой локальный кэш, который бот поддерживает для хранения объекта состояния и обработки чтения и записи без фактического доступа к базовому хранилищу. Если нужного состояния нет в кэше, вызванный метод доступа *get* получает его из хранилища и помещает в кэш. Полученное свойство состояния можно изменять так же, как и обычную локальную переменную.

Метод доступа *delete* удаляет свойство из кэша, а также из базового хранилища.

> [!IMPORTANT]
> При первом вызове метода доступа *get* ему необходимо предоставить фабричный метод, позволяющий создать объект, если он отсутствует в нужном состоянии. Если фабричный метод не предоставлен, создается исключение. Сведения об использовании фабричного метода можно найти в [практическом руководстве по работе с состоянием](bot-builder-howto-v4-state.md).

Чтобы сохранить изменения, внесенные в полученное свойство состояния, обновите свойство в кэше состояния. Для этого можно вызвать метод доступа *set*, который устанавливает значение свойства в кэше, т. е. делает новое значение доступным для чтения и (или) обновления далее на том же шаге. Чтобы сохранить эти данные в базовом хранилище (т. е. сделать их доступными на следующем шаге бота), необходимо [сохранить состояние](#saving-state).

### <a name="how-the-state-property-accessor-methods-work"></a>Как работают методы доступа к свойству состояния

Методы доступа являются основным средством для взаимодействия бота с состоянием. Ниже описаны принцип работы и взаимодействие базовых уровней для каждого из них.

- Метод доступа *get*
    - Метод доступа запрашивает данные из кэша состояний
    - Если нужное свойство находится в кэше, оно сразу возвращается. В противном случае оно извлекается из объекта управления состоянием.
        - Если в состоянии еще нет этого объекта, применяется фабричный метод, предоставленный при вызове метода доступа *get*.
- Метод доступа *set*
    - Сохраняет в кэше состояний новое значение свойства.
- Метод *save changes* в объекте управления состоянием:
    - Проверяет изменения свойства в кэше состояний.
    - Сохраняет нужное свойство в хранилище.

## <a name="saving-state"></a>Сохранение состояния

Если вы вызываете метод доступа set для сохранения обновленного состояния, свойство состояния не сохраняется в постоянное хранилище, а обновляется только в кэше состояний вашего бота. Чтобы сохранить в постоянное хранилище все внесенные в кэше изменения, следует вызвать метод *save changes* в объекте управления состоянием, который доступен через вышеупомянутую реализацию класса состояния бота (например, состояния пользователя или состояния беседы).

Вызов метода сохранения изменений в объекте управления состоянием (например, для вышеупомянутых контейнеров) сохраняет в выбранный контейнер все свойства, обновленные на текущий момент в кэше состояний, но не затрагивает другие контейнеры в состоянии бота.

> [!TIP]
> Состояние бота реализует подход "приоритет имеет последняя запись", т. е. последняя операция записи отменяет все ранее сохраненные состояния. Это допустимо для многих приложений, но имеет свои побочные эффекты, особенно в сценариях горизонтального масштабирования с определенным уровнем параллелизма и (или) задержек.

Если у вас есть пользовательское ПО промежуточного слоя, которое может обновлять состояние после завершения обработчика шага, есть смысл [управлять состоянием в этом ПО промежуточного слоя](bot-builder-concept-middleware.md#handling-state-in-middleware).

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Состояние в Dialog](bot-builder-concept-dialog.md#dialog-state)
- [Непосредственная запись в хранилище](bot-builder-howto-v4-storage.md)
- [Сохранение данных пользователя и диалога](bot-builder-howto-v4-state.md)